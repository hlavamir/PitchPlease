<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core</name>
    </assembly>
    <members>
        <member name="T:KPreisser.AsyncReaderWriterLockSlim">
            <summary>
            An alternative to <see cref="T:System.Threading.ReaderWriterLockSlim"/> which can be used in async methods.
            </summary>
            <remarks>
            This implementation has the following differences to <see cref="T:System.Threading.ReaderWriterLockSlim"/>:
            - The lock is not thread-affine, which means one thread can enter the lock,
              and a different thread can release it. This allows you to use the lock in an async
              method with a await call between entering and releasing the lock.
            - Additionally to synchronous methods like <see cref="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLock(System.Threading.CancellationToken)"/>,
              it has asynchronous methods like <see cref="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLockAsync(System.Threading.CancellationToken)"/> which
              can be called in async methods, so that the current thread is not blocked while waiting
              for the lock.
            - Because this class doesn't have thread affinity, recursive locks are not supported (which
              also means they cannot be detected). In order for the lock to work correctly, you must not
              recursively enter the lock from the same execution flow.
            - The lock does not support upgradeable read mode locks that can be upgraded to a write mode
              lock, due to the complexity this would add.
              
            The lock can have different modes:
            - Read mode: One or more 'read mode' locks can be active at a time while no 'write mode' lock
              is active.
            - Write Mode: One 'write mode' lock can be active at a time while no other
              'write mode' locks and no other 'read mode' locks are active.
            
            When a task or thread ("execution flow") tries to enter a 'write mode' lock while at least one
            'read mode' lock is active, it is blocked until the last 'read mode' lock is released.
            
            When a task or thread tries to enter a 'read mode' lock while a 'write mode' lock is active,
            it is blocked until the 'write mode' lock is released.
            
            If, while other 'read mode' locks are active and the current task or thread waits to enter
            the 'write mode' lock, another task or thread tries
            to enter a 'read mode' lock, it is blocked until
            the current task or thread released the 'write mode' lock (or canceled the wait operation), 
            which means writers are favored in this case.
            
            Also, when a 'write mode' lock is released while there are one or more execution flows
            trying to enter a *write mode* lock and also one or more execution flows trying to enter a
            'read mode' lock, writers are favored.
            
            The lock internally uses <see cref="T:System.Threading.SemaphoreSlim"/>s to implement wait functionality.
            </remarks>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.writeLockSemaphore">
            <summary>
            A <see cref="T:System.Threading.SemaphoreSlim"/> which is used to manage the write lock.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.readLockReleaseSemaphore">
            <summary>
            A <see cref="T:System.Threading.SemaphoreSlim"/> which a write lock uses to wait until the last
            active read lock is released.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentWriteLockState">
            <summary>
            If not <c>null</c>, contains the <see cref="T:KPreisser.AsyncReaderWriterLockSlim.WriteLockState"/> that represents the
            state of the current write lock. This field may be set even if
            <see cref="F:KPreisser.AsyncReaderWriterLockSlim.currentReadLockCount"/> is not yet 0, in which case the task or thread
            trying to get the write lock needs to wait until the existing read locks are left.
            However, while this field is set, no new read locks can be acquired.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentReadLockCount">
            <summary>
            The number of currently held read locks.
            </summary>
        </member>
        <member name="F:KPreisser.AsyncReaderWriterLockSlim.currentWaitingWriteLockCount">
            <summary>
            The number of tasks or threads that intend to wait on the <see cref="F:KPreisser.AsyncReaderWriterLockSlim.writeLockSemaphore"/>.
            This is used to check if the <see cref="F:KPreisser.AsyncReaderWriterLockSlim.currentWriteLockState"/> should already be
            cleaned-up when the write lock is released.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> class.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/>.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLock(System.Threading.CancellationToken)">
            <summary>
            Enters the lock in read mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in read mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete when the lock has been entered.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterReadLock(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns><c>true</c> if the lock has been entered, otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterReadLockAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a result of <c>true</c> if the lock has been entered,
            otherwise with a result of <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterWriteLock(System.Threading.CancellationToken)">
            <summary>
            Enters the lock in write mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.EnterWriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in write mode.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete when the lock has been entered.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterWriteLock(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns><c>true</c> if the lock has been entered, otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.TryEnterWriteLockAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a result of <c>true</c> if the lock has been entered,
            otherwise with a result of <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.DowngradeWriteLockToReadLock">
            <summary>
            Downgrades the lock from write mode to read mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.ExitReadLock">
            <summary>
            Exits read mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.ExitWriteLock">
            <summary>
            Exits write mode.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlim.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> and
            optionally releases the managed resources.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsActive">
            <summary>
            Gets or sets a value that indicates if the state is active. Only when <c>true</c>, the
            <see cref="F:KPreisser.AsyncReaderWriterLockSlim.readLockReleaseSemaphore"/> will be released once the last read lock exits.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsReleased">
            <summary>
            Gets or sets a value that indicates if the write lock associated with this
            <see cref="T:KPreisser.AsyncReaderWriterLockSlim.WriteLockState"/> has already been released. This is also used
            to indicate if the the task or thread that waits on the
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore and then decrements
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksCount"/> to zero (0) must dispose the
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore">
            <summary>
            Gets or sets a <see cref="T:System.Threading.SemaphoreSlim"/> on which new read locks need
            to wait until the existing write lock is released. The <see cref="T:System.Threading.SemaphoreSlim"/>
            will be created only if there is at least on additional task or thread that wants
            to enter a read lock.
            </summary>
        </member>
        <member name="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksCount">
            <summary>
            Gets or sets a value that indicates the number of tasks or threads which intend
            to wait on the <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> semaphore. This
            is used to determine which task or thread is responsible to dispose the 
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.WaitingReadLocksSemaphore"/> if
            <see cref="P:KPreisser.AsyncReaderWriterLockSlim.WriteLockState.StateIsReleased"/> is <c>true</c>.
            </summary>
        </member>
        <member name="T:KPreisser.AsyncReaderWriterLockSlimExtension">
            <summary>
            Contains extension methods for <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/>.
            </summary>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetReadLock(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Enters the lock in read mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetReadLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in read mode and returns a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that
            will release the lock when disposed.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> when the lock has been entered,
            which will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetReadLock(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed if the lock
            could be entered, or <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetReadLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in read mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock
            when disposed if the lock could be entered, or with <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetWriteLock(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Enters the lock in write mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.GetWriteLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously enters the lock in write mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> when the lock has been entered,
            which will release the lock when disposed.</returns>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetWriteLock(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>A <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock when disposed if the lock
            could be entered, or <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.TryGetWriteLockAsync(KPreisser.AsyncReaderWriterLockSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tries to asynchronously enter the lock in write mode, with an optional integer time-out.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1
            (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>>A task that will complete with a <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> that will release the lock
            when disposed if the lock could be entered, or with <c>null</c> otherwise.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number
            other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="M:KPreisser.AsyncReaderWriterLockSlimExtension.DowngradeWriteLockToReadLock(KPreisser.AsyncReaderWriterLockSlim,KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock)">
            <summary>
            Downgrades the lock from write mode to read mode.
            </summary>
            <param name="lockInstance">The <see cref="T:KPreisser.AsyncReaderWriterLockSlim"/> instance.</param>
            <param name="readLock">The <see cref="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock"/> which should be downgraded.</param>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        </member>
        <member name="T:KPreisser.AsyncReaderWriterLockSlimExtension.IDisposableLock">
            <summary>
            
            </summary>
        </member>
        <member name="M:KPreisser.TimeUtils.GetTimestampTicks(System.Boolean)">
            <summary>
            Gets a timestamp in DateTime Ticks that contains the time elapsed since the
            system has started, or (if <paramref name="unbiased"/> is <c>true</c>) the time
            the system has spent in the working state.
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Core.ElementAttribute.TracingId">
            <summary>
            The element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsImmutable">
            <summary>
            Whether or not the type is immutable.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsManaged">
            <summary>
            Whether or not the field will be disposed when it goes out of scope during a hotswap.
            </summary>
        </member>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapped">
            <summary>
            Allows objects to get notified when they've been hot swapped.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapped.Swapped(System.Object)">
            <summary>
            Called after the object has been replaced by a new instance.
            </summary>
        </member>
        <member name="T:VL.Core.HotSwapAttribute">
            <summary>
            Forces the hot swapper to call the constructor of this type and only swap fields which also have this attribute set.
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescriptionFactory">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLNodeDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPinDescription">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLNode">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLPin">
            <summary>
            WARNING: This interface is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.NodeFactoryAttribute">
            <summary>
            WARNING: This attribute is experimental!
            </summary>
        </member>
        <member name="T:VL.Core.IVLObject">
            <summary>
            Non-generic interface implemented by VL emitted classes and records.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Context">
            <summary>
            The context in which this instance was created.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Type">
            <summary>
            The type of the object.
            </summary>
        </member>
        <member name="T:VL.Core.IVLHub">
            <summary>
            Interface to interact with VL data hubs.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Name">
            <summary>
            The name of the data hub.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Type">
            <summary>
            The type of the data hub.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Value">
            <summary>
            The current value of the data hub.
            </summary>
        </member>
        <member name="T:VL.Core.IVLRuntime">
            <summary>
            Interface to interact with the VL runtime.
            </summary>
        </member>
        <member name="P:VL.Core.IVLRuntime.IsRunning">
            <summary>
            Whether or not VL is in a running state. If not calls into its object graph are not allowed.
            </summary>
        </member>
        <member name="T:VL.Core.IVLFactory">
            <summary>
            Interface to create VL objects.
            </summary>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeByName(System.String)">
            <summary>
            Retrieve the registered type of the given full type name.
            </summary>
            <param name="name">The full name of the type.</param>
            <returns>The type with the given full name or null.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeInfo(System.Type)">
            <summary>
            Wrap the CLR type in a VL type info.
            </summary>
            <param name="type">The CLR type to wrap.</param>
            <returns>The VL type info wrapping the given CLR type.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.IsKnownType(System.Type)">
            <summary>
            Whether or not the given CLR type is known to the factory. Only type as seen by the compiler are considered to be known types.
            </summary>
            <param name="type">The type in question.</param>
            <returns>True if the type is known to the VL compiler.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.CreateInstance(System.Type,VL.Core.NodeContext)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="type">The type to create a new instance of.</param>
            <param name="nodeContext">The context to use when creating the instance.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetDefaultValue(System.Type)">
            <summary>
            Returns the default value of the given type as defined by VL through the CreateDefault operations.
            </summary>
            <param name="type">The type to return the default value of.</param>
            <returns>The default value of the given type as defined by VL or null if the type is not known to VL or no default has been defined.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.RegisterService(System.Type,System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a factory function which gets invoked when a certain service of type <paramref name="serviceType"/> is requested for
            a specific value of type <paramref name="forType"/>. The factory function must return a service of the specified <paramref name="serviceType"/>.
            </summary>
            <param name="forType">The type of the value for which a service will be requested.</param>
            <param name="serviceType">The type of the service.</param>
            <param name="serviceFactory">The factory function creating such a service.</param>
        </member>
        <member name="M:VL.Core.IVLFactory.GetServiceFactory(System.Type,System.Type)">
            <summary>
            Retrieves the factory function which will create the service of type <paramref name="serviceType"/> for the given <paramref name="forType"/>.
            </summary>
            <param name="forType">The type of the value for which a service is requested.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>The factory function creating the service or null.</returns>
        </member>
        <member name="T:VL.Core.IVLTypeInfo">
            <summary>
            Interface to interact with VL types.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.ClrType">
            <summary>
            The CLR type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsPatched">
            <summary>
            Whether or not this type is a patched VL type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsClass">
            <summary>
            Whether or not this type is a VL class (mutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsRecord">
            <summary>
            Whether or not this type is a VL record (immutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Properties">
            <summary>
            The user defined properties of this type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.AllProperties">
            <summary>
            The user defined and system generated properties of this type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetProperty(System.String)">
            <summary>
            Returns the property with the given name.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The property or null.</returns>
        </member>
        <member name="T:VL.Core.IVLPropertyInfo">
            <summary>
            Interface to interact with VL properties.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DeclaringType">
            <summary>
            The type which declared this property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Id">
            <summary>
            The id of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Name">
            <summary>
            The name of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Type">
            <summary>
            The type of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DefaultValue">
            <summary>
            The default value of the property. As of now this is just the default value of the type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.GetValue(VL.Core.IVLObject)">
            <summary>
            Gets the property value of the given instance.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <returns>The value of the property.</returns>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.WithValue(VL.Core.IVLObject,System.Object)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <param name="instance">The instance to set the value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the newly set value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetDefaultValue``1(VL.Core.IVLFactory)">
            <summary>
            Returns the VL defined default value for the given type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type for which to return the VL defined default value.</typeparam>
            <param name="factory">The factory to use to create the default value.</param>
            <returns>The VL defined default value of the given type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateInstance``1(VL.Core.IVLFactory,``0,VL.Core.NodeContext,``0@)">
            <summary>
            Tries to create an instance of the given type <typeparamref name="T"/> using the VL generated constructor.
            Returns true in case an instance was created.
            </summary>
            <typeparam name="T">The type of which to create an instance for.</typeparam>
            <param name="factory">The factory which will create the instance.</param>
            <param name="defaultValue">The default value to use in case an instance couldn't be created.</param>
            <param name="nodeContext">The context in which the new instance will be created.</param>
            <param name="instance">The newly created instance or the given default value.</param>
            <returns>True in case a new instance was created.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``2(VL.Core.IVLFactory,System.Func{``0,``1})">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested for
            a value of type <typeparamref name="TForType"/>.
            </summary>
            <typeparam name="TForType">The type of the value for which a service will be requested.</typeparam>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="create">The factory function to invoke when such a service is requested.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateService``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateService``1(VL.Core.IVLFactory,System.Object,``0,``0@)">
            <summary>
            Tries to create a service of the given type <typeparamref name="TService"/> for the given value.
            Returns true if such a service was found for the given value, otherwise the given default service will be used.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <param name="defaultService">The default service to use in case no service of that type was registered for the type of the value.</param>
            <param name="service">The registered service or the given default service.</param>
            <returns>True in case a service was found and created.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValue``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given property.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The instance to retrieve the value from.</param>
            <param name="name">The name of the property.</param>
            <param name="defaultValue">The default value to use in case retrieval failed.</param>
            <param name="value">The returned values.</param>
            <returns>True if the retrieval succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValue``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given property and returns a new instance (if it is a record) with the set value.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="instance">The instance to set the property value on.</param>
            <param name="name">The name of the property.</param>
            <param name="value">The value to set.</param>
            <returns>The new instance (if it is a record) with the set value.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValueByPath``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" retrieves the first value in MySpread.</param>
            <param name="defaultValue">The default value to use in case the lookup failed.</param>
            <param name="value">The returned value.</param>
            <returns>True if the lookup succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValueByPath``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" sets the first value in MySpread.</param>
            <param name="value">The value to set.</param>
            <returns>The new root instance (if it is a record) with the updated spine.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.TryGetValue``1(VL.Core.IVLPropertyInfo,VL.Core.IVLObject,``0,``0@)">
            <summary>
            Tries to get the property value of the given instance.
            </summary>
            <typeparam name="T">The expected type of the property value.</typeparam>
            <param name="property">The property to read.</param>
            <param name="instance">The instance to get the property value from.</param>
            <param name="defaultValue">The value to return in case retrieval failed.</param>
            <param name="value">The retrieved property value.</param>
            <returns>Whether or not the operation succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.WithValue``2(VL.Core.IVLPropertyInfo,``0,``1)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="property">The property to write.</param>
            <param name="instance">The instance to set the property value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the set value.</returns>
        </member>
        <member name="T:VL.Core.NodeContext">
            <summary>
            Contains information about the environment in which a node was created.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Default">
            <summary>
            The default context.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.Create(System.UInt32,VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new root context.
            </summary>
            <param name="rootId">The root id.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context is immutable.</param>
            <returns>The new root context.</returns>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Collections.Immutable.ImmutableStack{System.UInt32},VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new context.
            </summary>
            <param name="path">The path to the node for which this context gets created.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context must be immutable.</param>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the context.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Path">
            <summary>
            The path to the node.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.IsImmutable">
            <summary>
            Whether or not the context is immutable. In an immutable context the state must not be modified.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.CreateSubContext(System.UInt32)">
            <summary>
            Creates a new sub context.
            </summary>
        </member>
        <member name="T:VL.Core.Properties.Settings">
            <summary>
            Global HDE settings
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.NodeShowImplementationIcon">
            <summary>
            Show the icon for a nodes implementation (patch/code) even for nodes that are not in the &quot;Main&quot; namespace
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeSupport">
            <summary>
            When enabled values as well as timing information can be inspected at runtime. Has minor impact on performance however.
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowDocumentation">
            <summary>
            Display code documentation 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowLocalID">
            <summary>
            Display an items localID
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowOperation">
            <summary>
            Display the Operation an item is part of 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.MouseWheelZooms">
            <summary>
            Mouse wheel zooms, + ALT pans vertically, + SHIFT pans horizontally. Otherwise mouse wheel pans vertically, + CTRL zooms
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeDisableJITOptimizations">
            <summary>
            Disables JIT optimizations for dynamically emitted assemblies. Should a runtime exception occur the nodes colored red should always match the stack trace.
            </summary>
        </member>
        <member name="T:VL.Core.RuntimeGraph">
            <summary>
            A collection of methods used by nodes which introduce new entry points into the VL runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Enter">
            <summary>
            Call when entering the VL runtime graph from a background thread.
            </summary>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.EnterAsync">
            <summary>
            Call when entering the VL runtime graph from a main thread. Do NOT use it from a background thread as it would spawn many new tasks over time
            if another background task takes a long time to complete.
            </summary>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Pause(System.Threading.CancellationToken)">
            <summary>
            Stops instances from entering the VL runtime graph.
            </summary>
            <param name="cancellationToken">The cancellation token used to cancel the lock.</param>
            <returns>A disposable that releases the lock when disposed.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.HandleException(System.UInt32)">
            <summary>
            If an exception is set and it traces back to the given root process then it will be unset and thrown.
            </summary>
            <param name="rootId"></param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.ReportException(System.Exception)">
            <summary>
            The exception to throw by the HandleAsyncException call.
            </summary>
            <param name="exception">The exception to report.</param>
        </member>
        <member name="T:VL.Core.SafeLazy`1">
            <summary>
            Provides support for lazy initialization with recursive fallback options.
            </summary>
            <typeparam name="T">The type of object that is being lazily initialized.</typeparam>
        </member>
        <member name="M:VL.Core.SafeLazy`1.GetValue(System.Func{`0},System.Func{`0})">
            <summary>
            Gets the lazily initialized value. 
            Will throw a <see cref="T:VL.Core.RecursiveCallException"/> in case the factory call is recursive and <paramref name="recursiveFallback"/> is null.
            If the <paramref name="recursiveFallback"/> is set it will be used to produce an intermediate result instead of throwing the <see cref="T:VL.Core.RecursiveCallException"/>.
            </summary>
            <param name="factory">The factory function to produce the value.</param>
            <param name="recursiveFallback">The fallback function in case the factory call is recursive. If null a <see cref="T:VL.Core.RecursiveCallException"/> will be thrown.</param>
            <returns>The lazily initialized value.</returns>
        </member>
        <member name="T:VL.Core.RecursiveCallException">
            <summary>
            This exception is thrown when the factory function of <see cref="T:VL.Core.SafeLazy`1"/> leads to a recursion.
            </summary>
        </member>
        <member name="T:VL.Core.ISerializer`1">
            <summary>
            The serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.ISerializer`1.Serialize(VL.Core.SerializationContext,`0)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.ISerializer`1.Deserialize(VL.Core.SerializationContext,System.Object,System.Type,`0)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.SerializationContext">
            <summary>
            The serialization context.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.#ctor(VL.Core.IVLFactory,System.Boolean,System.Boolean)">
            <summary>
            Creates a new serialization context.
            </summary>
            <param name="factory">The VL factory.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
        </member>
        <member name="P:VL.Core.SerializationContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.ThrowOnError">
            <summary>
            Whether or not serialization error should lead to an exception
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.IncludeDefaults">
            <summary>
            Whether or not default values will also be serialized.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Errors">
            <summary>
            The accumulated error messages.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.ReportError(System.String)">
            <summary>
            Reports an error. Will throw a <see cref="T:VL.Core.SerializationException"/> in case <see cref="P:VL.Core.SerializationContext.ThrowOnError"/> is enabled.
            </summary>
            <param name="message">The error message to report.</param>
        </member>
        <member name="T:VL.Core.SerializationException">
            <summary>
            Represents errors that occur during serialization.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationException.#ctor(System.String)">
            <summary>
            Creates a new instances of the <see cref="T:VL.Core.SerializationException"/> class with the specified error message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:VL.Core.Serialization">
            <summary>
            Serialization related extension methods and constants.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.ReflectionNamespace">
            <summary>
            The reflection namespace.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.TypeAttributeName">
            <summary>
            The name of the type attribute.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.GetSimpleName(System.Type)">
            <summary>
            Returns the name of the type without any generic type parameter suffixes and replaces [] with Array.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.GetSimpleFullName(System.Type)">
            <summary>
            Returns the full name of the type without any generic type parameter suffixes.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializer``2(VL.Core.IVLFactory,``1)">
            <summary>
            Registers a VL serializer to the factory. 
            In case the type for which the serializer gets registered is generic a dummy type instantiation paired with a dummy
            serializer instantiation containing a public default constructor has to be registered. For example a serializer implementation
            of type FooSerializer&lt;T&gt; for the generic type Foo&lt;T&gt; has to be registered for the dummy instantiaton Foo&lt;object&gt;.
            </summary>
            <typeparam name="TForType">The type for which to register a serializer.</typeparam>
            <typeparam name="TSerializer">The type of the serializer implementation.</typeparam>
            <param name="factory">The factory in which the serializer gets registered.</param>
            <param name="serializer">The serializer to register.</param>
            <returns>The factory with the registered serializer.</returns>
        </member>
        <member name="M:VL.Core.Serialization.CanSerialize(VL.Core.IVLFactory,System.Type)">
            <summary>
            Whether or not an instance of the given type can be serialized.
            </summary>
            <param name="factory">The factory containing the serializer registrations.</param>
            <param name="forType">The type of the instance to serialize.</param>
            <returns>True if an instance of the given type can be serialized.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.SerializationContext,System.String,``0,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </typeparam>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize(VL.Core.SerializationContext,System.String,System.Object,System.Type,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="staticType">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.SerializationContext,System.Object,System.String,``0)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize(VL.Core.SerializationContext,System.Object,System.String,System.Type,System.Object)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="staticType">The statically known type of the value to deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.CollectionSerializer`2">
            <summary>
            The abstract base class to use when writing a VL serializer for a collection type.
            </summary>
            <typeparam name="TElement">The element type of the collection.</typeparam>
            <typeparam name="TCollection">The type of the collection.</typeparam>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case serialization fails.</remarks>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0,System.Boolean,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement)">
            <summary>
            Deserializes the given content.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case deserialization fails.</remarks>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Deserializes the given content.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="throwOnError">Whether or not deserialization errors should lead to an exception.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializers(VL.Core.IVLFactory)">
            <summary>
            Registers all the default serializers in the factory.
            </summary>
            <param name="factory">The factory to register in.</param>
        </member>
        <member name="M:VL.Core.Serialization.GetSerializer(VL.Core.IVLFactory,System.Type)">
            <summary>
            Gets a serializer for the given type.
            </summary>
            <param name="factory">The factory to fetch the serializer from.</param>
            <param name="forType">The type for which a serializer has to be fetched.</param>
            <returns>The serializer or null in case no serializer is registered for that type.</returns>
        </member>
        <member name="T:VL.Core.Serialization.Serializer">
            <summary>
            The non-generic serializer class.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Serialize(VL.Core.SerializationContext,System.Object)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized value as <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Deserialize(VL.Core.SerializationContext,System.Object,System.Type,System.Object)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.UngenericDelegatingSerializer`1">
            <summary>
            Bridge to user implemented generic serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="T:VL.Core.IHasMemory`1">
            <summary>
            Allows to get access to the backing <see cref="T:System.ReadOnlyMemory`1"/> or <see cref="T:System.Memory`1"/> of the implementing class.
            </summary>
            <remarks>
            Currently implemented by <see cref="T:VL.Lib.Collections.Spread`1" /> and <see cref="T:VL.Lib.Collections.SpreadBuilder`1"/>
            </remarks>
            <typeparam name="T">The elment type.</typeparam>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.Memory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.Memory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.Memory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.Memory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.IHasMemory`1.TryGetMemory(System.ReadOnlyMemory{`0}@)">
            <summary>
            Tries to get access on the backing continuous <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <param name="memory">The continuous block of <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>Whether or not access to the <see cref="T:System.ReadOnlyMemory`1"/> is granted.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Empty``1">
            <summary>
            Returns empty memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <returns>The empty memory.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.HasData``1(VL.Core.IHasMemory{``0})">
            <summary>
            Wether or not not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>True if not-empty <see cref="T:System.ReadOnlyMemory`1"/> is available.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Length``1(VL.Core.IHasMemory{``0})">
            <summary>
            The length in elements of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The length of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.Size``1(VL.Core.IHasMemory{``0})">
            <summary>
            The size in bytes of the memory block.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size in bytes of the memory block.</returns>
        </member>
        <member name="M:VL.Core.HasMemoryExtensions.ElementSize``1(VL.Core.IHasMemory{``0})">
            <summary>
            Returns the size in bytes of one element of the memory.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="instance">The instance providing the memory.</param>
            <returns>The size of one element in bytes.</returns>
        </member>
        <member name="T:VL.Core.MapMode">
            <summary>
            vvvv like modi for the Map function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Float">
            <summary>
            Maps the value continously
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Clamp">
            <summary>
            Maps the value, but clamps it at the min/max borders of the output range
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Wrap">
            <summary>
            Maps the value, but repeats it into the min/max range, like a modulo function
            </summary>
        </member>
        <member name="F:VL.Core.MapMode.Mirror">
            <summary>
            Maps the value, but mirrors it into the min/max range, always against either start or end, whatever is closer
            </summary>
        </member>
        <member name="T:VL.Core.VLMath">
            <summary>
            The vvvv c# math routines library
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.Pi">
            <summary>
            Pi, as you know it
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPi">
            <summary>
            Pi * 2
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.PiRez">
            <summary>
            1 / Pi, multiply by this if you have to divide by Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.TwoPiRez">
            <summary>
            2 / Pi, multiply by this if you have to divide by 2*Pi
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToRad">
            <summary>
            Conversion factor from cycles to radians, (2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToCyc">
            <summary>
            Conversion factor from radians to cycles, 1/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToRad">
            <summary>
            Conversion factor from degree to radians, (2 * Pi)/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.RadToDeg">
            <summary>
            Conversion factor from radians to degree, 360/(2 * Pi)
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.DegToCyc">
            <summary>
            Conversion factor from degree to radians, 1/360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.CycToDeg">
            <summary>
            Conversion factor from radians to degree, 360
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.IdentityMatrix">
            <summary>
            Identity matrix 
            1000 
            0100
            0010
            0001
            </summary>
        </member>
        <member name="F:VL.Core.VLMath.Random">
            <summary>
            A random object for conveninece
            </summary>
        </member>
        <member name="M:VL.Core.VLMath.RandomVector2">
            <summary>
            Creates a random 2d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VL.Core.VLMath.RandomVector3">
            <summary>
            Creates a random 3d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VL.Core.VLMath.RandomVector4">
            <summary>
            Creates a random 4d vector.
            </summary>
            <returns>Random vector with its components in the range [-1..1].</returns>
        </member>
        <member name="M:VL.Core.VLMath.Factorial(System.Int32)">
            <summary>
            Factorial function, DON'T FEED ME WITH LARGE NUMBERS !!! (n>10 can be huge)
            </summary>
            <param name="n"></param>
            <returns>The product n * n-1 * n-2 * n-3 * .. * 3 * 2 * 1</returns>
        </member>
        <member name="M:VL.Core.VLMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Binomial function
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns>The number of k-tuples of n items</returns>
        </member>
        <member name="M:VL.Core.VLMath.Pow(System.Single,System.Int32)">
            <summary>
            Raises x to the power of y.
            </summary>
            <param name="x">The base.</param>
            <param name="y">The exponent.</param>
            <returns>Returns x raised to the power of y.</returns>
            <remarks>This method should be considerably faster than Math.Pow for small y.</remarks>
        </member>
        <member name="M:VL.Core.VLMath.SolveQuadratic(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Solves a quadratic equation a*x^2 + b*x + c for x
            </summary>
            <param name="a">Coefficient of x^2</param>
            <param name="b">Coefficient of x</param>
            <param name="c">Constant</param>
            <param name="x1">First solution</param>
            <param name="x2">Second solution</param>
            <returns>Number of solution, 0, 1, 2 or int.MaxValue</returns>
        </member>
        <member name="M:VL.Core.VLMath.Min(System.Single,System.Single)">
            <summary>
            Min function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Smaller value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Max(System.Single,System.Single)">
            <summary>
            Max function
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Greater value of the two input parameters</returns>
        </member>
        <member name="M:VL.Core.VLMath.Zmod(System.Int32,System.Int32)">
            <summary>
            Modulo function with the property, that the remainder of a division z / d
            and z &lt; 0 is positive. For example: zmod(-2, 30) = 28.
            </summary>
            <param name="z"></param>
            <param name="d"></param>
            <returns>Remainder of division z / d.</returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a floating point value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamp function, clamps an integer value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(System.Int64,System.Int64,System.Int64)">
            <summary>
            Clamp function, clamps a long value into the range [min..max]
            </summary>
            <param name="x"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector2,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector3,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector4,System.Single,System.Single)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector2,SharpDX.Vector2,SharpDX.Vector2)">
            <summary>
            Clamp function, clamps a 2d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3)">
            <summary>
            Clamp function, clamps a 3d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Clamp(SharpDX.Vector4,SharpDX.Vector4,SharpDX.Vector4)">
            <summary>
            Clamp function, clamps a 4d-vector into the range [min..max]
            </summary>
            <param name="v"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(System.Single)">
            <summary>
            Abs function for values, just for completeness
            </summary>
            <param name="a"></param>
            <returns>New value with the absolut value of a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(SharpDX.Vector2)">
            <summary>
            Abs function for 2d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(SharpDX.Vector3)">
            <summary>
            Abs function for 3d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Abs(SharpDX.Vector4)">
            <summary>
            Abs function for 4d-vectors
            </summary>
            <param name="a"></param>
            <returns>New vector with the absolut values of the components of input vector a</returns>
        </member>
        <member name="M:VL.Core.VLMath.Ratio(System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            This Method can be seen as an inverse of Lerp (in Mode Float). Additionally it provides the infamous Mapping Modes, author: velcrome
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="start">Minimum of input value range</param>
            <param name="end">Maximum of input value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(System.Single,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for values
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input value mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector2,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector3,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector4,System.Single,System.Single,System.Single,System.Single,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and value range bounds
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector2,SharpDX.Vector2,SharpDX.Vector2,SharpDX.Vector2,SharpDX.Vector2,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 2d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3,SharpDX.Vector3,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 3d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Map(SharpDX.Vector4,SharpDX.Vector4,SharpDX.Vector4,SharpDX.Vector4,SharpDX.Vector4,VL.Core.MapMode)">
            <summary>
            The infamous Map function of vvvv for 4d-vectors and range bounds given as vectors
            </summary>
            <param name="Input">Input value to convert</param>
            <param name="InMin">Minimum of input value range</param>
            <param name="InMax">Maximum of input value range</param>
            <param name="OutMin">Minimum of destination value range</param>
            <param name="OutMax">Maximum of destination value range</param>
            <param name="mode">Defines the behavior of the function if the input value exceeds the destination range 
            <see cref="T:VL.Core.MapMode">TMapMode</see></param>
            <returns>Input vector mapped from input range into destination range</returns>
        </member>
        <member name="M:VL.Core.VLMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation (blending) between two values
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="x"></param>
            <returns>Linear interpolation between a and b if x in the range ]0..1[ or a if x = 0 or b if x = 1</returns>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareAdded">
            <summary>
            Checks for device additions, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareRemoved">
            <summary>
            Checks for device removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareChanged">
            <summary>
            Checks for device additions and removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="T:VL.Lib.GUID_DEVCLASS">
            <summary>
             Defines GUIDs for device classes used in Plug &amp; Play.
            </summary>
        </member>
        <member name="T:VL.Lib.Reactive.HoldLatestCopy`2">
            <summary>
            Holds on to a copy of the latest received data. Whenever data gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Value">
            <summary>
            Gets the current enum value as string
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Tag">
            <summary>
            Gets the associated tag if the enum definition has registered one.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnum.CreateValue(System.String)">
            <summary>
            Creates a new enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Default">
            <summary>
            Creates the default enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Definition">
            <summary>
            Gets the definition of this enum with all entries
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.OnChange">
            <summary>
            Fires when the definition changes, i.e. entries get added or removed
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.Entries">
            <summary>
            Gets the current list of valid entries
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnumDefinition.IsValid(System.String)">
            <summary>
            Returns true if the string is a valid entry of this enum type
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.EmptyEnumFallbackMessage">
            <summary>
            Gets the empty enum fallback string for cases when no entries are in the enum definition.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.IsValid(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Returns true if the value is in the current entry list of the definition.
            </summary>
            <returns>
              <c>true</c> if the specified input is valid, not null and its value is not a null or empty string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.SelectedIndex(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Gets the index of the selected item in the entries list of its definition.
            Can return -1 if the string is not in the current list of entries.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.CreateValue``1(``0,System.String)">
            <summary>
            Creates a new enum value of given type
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.TrySelectIndex``1(``0,System.Int32,System.Boolean@,``0@)">
            <summary>
            Sets the selected item to the value at the index in the entries list of its definition.
            If the index is out of range, returns false and the input value.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumBase`2">
            <summary>
            Base class for easy dynamic enum implementaion. Use like this:
            MyEnumClass : DynamicEnumBase&lt;MyEnumClass&gt; and override 
            IDynamicEnumDefinition Definition { get; } and define a default value:
            public static MidiInputDevice Default => new MyEnumClass("Default Entry");
            <typeparam name="TSubclass">The type of the actual dynamic enum class.</typeparam>
            <typeparam name="TDefinitionClass">The type of the enum definition.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnum" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumBase`2.CreateDefaultBase(System.String)">
            <summary>
            Can be used in subclass to create the default, selects the first entry.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumDefinitionBase`1">
            <summary>
            Base class for dynamic enum definitions.
            Takes care of the singleton pattern and the update of the entries. Use like this:
            MyEnumDefinitionClass : DynamicEnumBase&lt;MyEnumDefinitionClass&gt; and override the two abstract methods.
            <typeparam name="TDefinitionSubclass">The type of the actual definition class.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnumDefinition" />
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpread">
            <summary>
            Non-generic spread interface.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.ToBuilder">
            <summary>
            Creates a spread builder with the same contents as this spread that can be efficiently modified across multiple operations
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.IsEmpty">
            <summary>
            Whether or not the spread is empty
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Count">
            <summary>
            Returns the number of slices in the spread
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Item(System.Int32)">
            <summary>
            Returns the item at the specified index. Can throw ArgumentOutOfRangeException exception
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Pin">
            <summary>
            Pins the internal data array of the spread on the garbage collector to access it from unmanaged code.
            Use at your own risk, i.e. never modify bytes in it. Also make sure Unpin gets called to avoid memory leaks.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Unpin">
            <summary>
            Frees the pinned garbage collector handle, if allocated.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.Spread">
            <summary>
            Contains all those methods which are used in C# and VL.
            Methods which are only used in VL reside in SpreadNodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.SizeInBytes``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            The size in bytes = element type size * count.
            Returns IntPtr * count for reference types.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.GetInternalArray``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            Gets the internal data array of the spread, use at your own risk, i.e. never modify it.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpreadBuilder">
            <summary>
            Non-generic view on spread builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ISpreadBuilder.ToSpread">
            <summary>
            Returns an immutable spread of the current contents of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at specified index
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies 'Count' elements from 'Start Index' to an Array at the 'Array Index' position
            </summary>
            <param name="array"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="arrayIndex"></param>
            <param name="reverseOrder"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort">
            <summary>
            Sorts the elements in the entire spread builder using the default comparer
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in the entire spread builder using the specified comparer function
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.FrameClock">
            <summary>
            The clock used to determine the time when the current frame of the vl mainloop started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentFrameTime">
            <summary>
            The time when the current frame started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.RealTimeClock">
            <summary>
            The clock used to determine the current time, returns a new time value for each call
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentTime">
            <summary>
            Checks time now
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTime(System.DateTime)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTimeUTC(System.DateTimeOffset)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.HoldLatestCopy">
            <summary>
            Holds on to a copy of the latest received image. Whenever an image gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageExtensions.Default">
            <summary>
            A white one by one pixel RGBA image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the array accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the data array gets modified later.</param>
            <returns>An image which uses the array as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the spread accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>An image which uses the spread as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.Drawing.Bitmap,System.Boolean,System.Boolean)">
            <summary>
            Makes the bitmap accessible as an image. No data gets copied.
            </summary>
            <param name="bitmap">The bitmap to wrap.</param>
            <param name="takeOwnership">Whether or not the wrapper should take ownership of the bitmap. So in case it gets disposed the bitmap will also get disposed.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the bitmap gets modified later.</param>
            <returns>The image wrapping the bitmap.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.IntPtr,System.Int32,System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the pointer accessible as an image. No data gets copied. The returned image is volatile and should get disposed of.
            Once disposed further access to <see cref="M:VL.Lib.Basics.Imaging.IImage.GetData"/> will return the image data from the default image.
            </summary>
            <param name="pointer">The pointer to the data of the image.</param>
            <param name="size">The size in bytes of the image data.</param>
            <param name="width">The width in pixel.</param>
            <param name="height">The height in pixel.</param>
            <param name="format">The pixel format.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>A volatile image using the pointer as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.Clone(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CloneEmpty(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates an empty clone of the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>An image of the same size and format but with all pixels set to zero.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ClonePooled(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image. The returned image uses memory from a pool and therefor must be disposed.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image. Ensure it gets disposed.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.ArrayImage{System.Byte}@)">
            <summary>
            Copies the source image to the destination location. If the destination is not yet assigned or if the image
            information doesn't fit a new image will be created and assigned to the destination.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The destination location to copy the image to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToStream(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Makes the image accessible as a stream.
            </summary>
            <param name="image">The image to wrap.</param>
            <returns>A stream which will read from the image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.ImageInfo,System.Byte*)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="srcInfo">The source image info.</param>
            <param name="dst">The destination pointer.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.ImageInfo,System.Byte*,System.UInt32)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="srcInfo">The source image info.</param>
            <param name="dst">The destination pointer.</param>
            <param name="dstScanSize">The size in bytes of one row including padding.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.FromImage(VL.Lib.Basics.Imaging.IImage,System.Boolean)">
            <summary>
            Makes the <see cref="T:VL.Lib.Basics.Imaging.IImage"/> accessible as a <see cref="T:System.Drawing.Bitmap"/> by either copying the pixels or wrapping them.
            </summary>
            <param name="image">The image to either copy the pixels from or wrap in a <see cref="T:System.Drawing.Bitmap"/>.</param>
            <param name="copy">Whether or not to copy the pixels.</param>
            <returns>The <see cref="T:System.Drawing.Bitmap"/> containing either the copied pixels or pointing to the upstream image data.</returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ImageInfo">
            <summary>
            A structure containing size information of an image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Width">
            <summary>
            The width of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Height">
            <summary>
            The height of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Format">
            <summary>
            The pixel format of the image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.OriginalFormat">
            <summary>
            The original pixel format as defined by the library the image was loaded from.
            Can be used in case the <see cref="F:VL.Lib.Basics.Imaging.ImageInfo.Format"/> property is set to <see cref="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.Split(System.Int32@,System.Int32@,VL.Lib.Basics.Imaging.PixelFormat@,System.String@)">
            <summary>
            Splits the image info up into its components.
            </summary>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The original format string (if any) of the image.</param>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.PixelSize">
            <summary>
            The size of a pixel in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ImageSize">
            <summary>
            The size of the image in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ScanSize">
            <summary>
            The size of one scan line (row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ArrayImage`1">
            <summary>
            Image implementation using an array as backing store.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PooledImage`1">
            <summary>
            Image implementation using a pooled array as backing store. Must be disposed.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.BitmapImage">
            <summary>
            Image implementation using a <see cref="T:System.Drawing.Bitmap"/> as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IntPtrImage">
            <summary>
            Image implementation using unmanaged memory as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImage">
            <summary>
            Gives read-only access to images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.Info">
            <summary>
            A structure containing size and format information of the image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.IImage.GetData">
            <summary>
            Gives access to image's data. Must be disposed after being used.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.IsVolatile">
            <summary>
            A volatile image is only valid in the current call stack.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImageData">
            <summary>
            Used for reading images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Pointer">
            <summary>
            The pointer to the data.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Size">
            <summary>
            The data size in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.ScanSize">
            <summary>
            The scan size (one row of pixels including padding) in bytes.
            </summary>
            <remarks>If the scan size times the image height is not equal to the size data copying has to be done row by row.</remarks>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PixelFormat">
            <summary>
            An enumeration of commonly used pixel formats.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown">
            <summary>
            Unkown pixel format.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8">
            <summary>
            A single-component, 8-bit unsigned-normalized-integer format that supports 8 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R16">
            <summary>
            A single-component, 16-bit unsigned-normalized-integer format that supports 16 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32F">
            <summary>
            A single-component, 32-bit floating-point format that supports 32 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8">
            <summary>
            24-bit RGB pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8">
            <summary>
            24-bit BGR pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8X8">
            <summary>
            32-bit RGBx pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8A8">
            <summary>
            32-bit RGBA pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8X8">
            <summary>
            32-bit BGRx pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8A8">
            <summary>
            32-bit BGRA pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32B32A32F">
            <summary>
            128-bit RGBA floating point pixel format using 32 bits for each channel.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.UsingAsync``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetch a resource, use it, let it get disposed of when the Task is done.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.ToObservable``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetches a resource and fires a result when the worker task is done. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool. Check the Cancelation token in your worker to stop work if cancelation was requested.
            </summary>        
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceProvider`1">
            <summary>
            Provides an IResourceHandle, which provides access to a Disposable resource.
            Consumers need to dispose these Handles.
            Implementations provide mechanisms for distributing and sharing Disposable resources.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceHandle`1">
            <summary>
            Is returned by IResourceProvider.GetHandle().
            Provides access to a Disposable Resource.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IConnectableResourceProvider`1">
            <summary>
            A connectable resource provider only works after calling Connect. 
            Disconnect via the disposable returned by Connect(). Only then the upstream handle gets disposed of.
            Used to share Resources more efficiently while connected.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooled``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0},System.Action{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Return``1(``0)">
            <summary>
            Will always provide same single resource. It exists already. 
            So its not the responsibility of Return() to dispose it.
            
            Could also imagine a ReturnLazy that takes a Func&lt;TResource&gt;, 
            but as it is used mostly inside the monade it is already lazy to GetHandle() from downstream
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}})">
            <summary>
            SelectMany
            Create a ResourceProvider per source resource. Creating any provider will work.
            Takes into account that the resulting resources may depend on the source resources.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will not get managed as it may exist already. (Select(form => form.Controls[0]) should not dispose the control)
            If you create a new resource that you want to get managed use BindNew for this.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a new resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will get managed.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Do``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Applies an action on a resource and outputs the same resource again.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Where``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Just doesn't let you access a resource that doesn't match your needs. Gives you null instead.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.PublishPooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            Manages a pool of handles from the upstream provider.
            On GetHandle, this will return a Handle containing a resource that is not currently in use.
            Manages a pool of upstream handles. When a downstream handle gets disposed, it's inner upstream Handle will be put back into the pool.
            
            Will dispose every upstream handle still in the pool on disconnect.
            Former disposable provider Pool
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``1(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.Int32)">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After delayDisposalInMilliseconds, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``2(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After disposalTriggerSource fired, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Serialize``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Handles get handed out in a serial fashion. Only one handle is in circulation at a given point in time.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32)">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify how long the resource stays valid after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify how long the resource stays valid. 
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify how long the resources in the pool stay valid after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Cata
            Empty using statement
            Only use for sideeffects of the upstream ResourceProvider Monad
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Cata
            Runs the action on the resource
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Cata
            Runs the extractor on the resource and returns the output.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``3(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Return a resource using two source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Return a resource using three source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Return a resource using four source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new resource using three source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new resource using four source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Handle`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Provider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.ConnectableProvider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable returned by Connect().
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.GetLatestResourceForTemporaryUse`1">
            <summary>
            Takes a resourceprovider and outputs its resource
            Makes sure to call GetHandle before releasing the old handle.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsFile">
            <summary>
            Returns whether the path is a file
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsDirectory">
            <summary>
            Returns whether the path is a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsRooted">
            <summary>
            Whether the path string contains a root.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Root">
            <summary>
            Returns the root path (if any).
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Size">
            <summary>
            Returns the size of a file or all the files in a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Exists">
            <summary>
            Returns whether file or folder exists
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.Refresh">
            <summary>
            Updates all properties of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.IO.Path.Parent">
            <summary>
            For a directory returns its parent directory. For a file returns the directory the file is in
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDescendants(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files and folders contained withinin a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDirectories(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all folders contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetFiles(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.Filename(System.String@,System.String@,System.String@)">
            <summary>
            Returns the directory path and the name and extension of a file
            </summary>
            <param name="directory"></param>
            <param name="filename"></param>
            <param name="extension"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.GetAttributes(System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.SetAttributes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.Modified(System.DateTime@,System.DateTime@,System.DateTime@)">
            <summary>
            Returns creation date, last write and last access dates of a file or folder
            </summary>
            <param name="creationTime"></param>
            <param name="lastWriteTime"></param>
            <param name="lastAccessTime"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeRelative(VL.Lib.IO.Path)">
            <summary>
            Returns this absolute path as a relative path to the given base path.
            In case the base path has a different root than this path or this path is relative already 
            the same path will be returned.
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeAbsolute(VL.Lib.IO.Path)">
            <summary>
            Returns this relative path as an absolute path to the given base path.
            In case this path is absolute already the same path will be returned.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.Permutations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            (a,b),(c,d) -> (a,c),(a,d),(b,c),(b,d)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions1.EnsureValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            create the value if not already stored for that key
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtIfNotEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            throws if input is empty. so please check that first
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.ClampedElementAtOrDefault``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>
            if count = 0 returns a default(T)
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.PointF})">
            <summary>
            Returns the bounds of the given point cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetBounds(System.Collections.Generic.IEnumerable{System.Drawing.RectangleF})">
            <summary>
            Returns the bounds of the given rectangle cloud.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Area(System.Drawing.SizeF)">
            <summary>
            Returns the area.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetCenter(System.Drawing.RectangleF)">
            <summary>
            Returns the center of this RectangleF.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetOnePixelRectangleForCenter(System.Drawing.PointF)">
            <summary>
            Returns a rectangle for given center position and 1 pixel size
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetRectangleForCenterAndSize(System.Drawing.PointF,System.Drawing.SizeF)">
            <summary>
            Returns a rectangle for given center position and size.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToRectangle(System.Drawing.RectangleF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Rectangle">Rectangle</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.ToPoint(System.Drawing.PointF)">
            <summary>
            Returns a <see cref="T:System.Drawing.Point">Point</see> by casting the float components to integer.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Plus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Minus(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Translates a given <see cref="T:System.Drawing.PointF">p1</see> by a specified <see cref="T:System.Drawing.PointF">p2</see>.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetSquaredDistanceTo(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Returns the squared distance to another point. Good for comparisons.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.Normalize(System.Drawing.PointF)">
            <summary>
            Normalizes the length
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.GetDistanceTo(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Returns the distance to another point.
            </summary>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformPoint(System.Drawing.Drawing2D.Matrix,System.Drawing.PointF)">
            <summary>
            Applies the transformation to a PointF
            </summary>
            <param name="t">A Matrix</param>
            <param name="p">The point to transform by the matrix t</param>
            <returns></returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.Rectangle)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
        <member name="M:System.Drawing.DrawingExtensions.TransformRectangle(System.Drawing.Drawing2D.Matrix,System.Drawing.RectangleF)">
            <summary>
            Applies the geometric transform represented by this Matrix to the
            given rectangle.
            </summary>
            <param name="t">A Matrix</param>
            <param name="rect">The rectangle to transform.</param>
            <returns>The transformed rectangle.</returns>
        </member>
    </members>
</doc>
