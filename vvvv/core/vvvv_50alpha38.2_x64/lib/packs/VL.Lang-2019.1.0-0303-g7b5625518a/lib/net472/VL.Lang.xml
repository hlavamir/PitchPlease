<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Lang</name>
    </assembly>
    <members>
        <member name="M:VL.Lang.Helper.AsyncHelpers.RunSync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Execute's an async <see cref="T:System.Threading.Tasks.Task"/> method which has a void return value synchronously
            </summary>
            <param name="task"><see cref="T:System.Threading.Tasks.Task"/> method to execute</param>
        </member>
        <member name="M:VL.Lang.Helper.AsyncHelpers.RunSync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Execute's an async <see cref="T:System.Threading.Tasks.Task`1"/> method which has a T return type synchronously
            </summary>
            <typeparam name="T">Return Type</typeparam>
            <param name="task"><see cref="T:System.Threading.Tasks.Task`1"/> method to execute</param>
            <returns></returns>
        </member>
        <member name="T:VL.Lang.UserInputPurpose">
            <summary>
            Decides whats the user input purpose to do string validation
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.GeneralString">
            <summary>
            Everything is allowed, e.g. for comments or string data
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.GeneralStringSingleline">
            <summary>
            Everything is allowed, e.g. for singleline comments
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Char">
            <summary>
            A single character
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Color">
            <summary>
            Must be in either HSVA "H:0.00 S:0.00 V:1.00 A:1.00", RGBA "H:0.00 S:0.00 V:1.00 A:1.00" or hex "xRRGGBBAA" format
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Boolean">
            <summary>
            Must be parseable into a boolean value
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Integer">
            <summary>
            Must be parseable into an integer number
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Float">
            <summary>
            Must be parseable into a floating point number
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Identifier">
            <summary>
            The string will be checked for the VL name string rules <see cref="T:VL.Lang.UserInputParsing"/>
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.IdentifierWithVersion">
            <summary>
            The input string can contain round brackets which contains a version name.
            After the parsing for name and version each will be checked for the VL name string rules <see cref="T:VL.Lang.UserInputParsing"/>
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.IdentifierWithSpaces">
            <summary>
            The string will be checked for the VL name string rules <see cref="T:VL.Lang.UserInputParsing"/> but spaces are allowed
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Category">
            <summary>
            A Category may start with a numeral
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.Categories">
            <summary>
            Several categories seperated by dots
            </summary>
        </member>
        <member name="F:VL.Lang.UserInputPurpose.TypeAnnotation">
            <summary>
            For closed type descriptions, allows strings like TypeName&lt;OtherType&gt;, TypeName [CategoryName]...
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidString(System.String,VL.Lang.UserInputPurpose,System.Boolean)">
            <summary>
            Checks whether a string has the correct format for the specified <see cref="T:VL.Lang.UserInputPurpose"/>
            </summary>
            <param name="userInput"></param>
            <param name="purpose"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="F:VL.Lang.UserInputParsing.VLUserInputNumberStyle">
            <summary>
            The VL allowed number style, its any but without thousands separator
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.CanParseBool(System.String)">
            <summary>
            Checks whether VL accepts the string as bool representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.CanParseInt(System.String)">
            <summary>
            Checks whether VL accepts the string as integer number representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseByte(System.String,System.Byte@)">
            <summary>
            Tries to parse the string as byte with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseSByte(System.String,System.SByte@)">
            <summary>
            Tries to parse the string as sbyte with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseShort(System.String,System.Int16@)">
            <summary>
            Tries to parse the string as short with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseUShort(System.String,System.UInt16@)">
            <summary>
            Tries to parse the string as ushort with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseInt(System.String,System.Int32@)">
            <summary>
            Tries to parse the string as integer with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseUInt(System.String,System.UInt32@)">
            <summary>
            Tries to parse the string as unsigned integer with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseLong(System.String,System.Int64@)">
            <summary>
            Tries to parse the string as long with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseULong(System.String,System.UInt64@)">
            <summary>
            Tries to parse the string as unsigned long with the VL allowed number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.CanParseFloat(System.String)">
            <summary>
            Checks whether VL accepts the string as floating number representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseFloat(System.String,System.Single@)">
            <summary>
            Tries to parse the string as float with the VL allowed Number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.TryParseDouble(System.String,System.Double@)">
            <summary>
            Tries to parse the string as double with the VL allowed Number style
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.SplitStringIntoPrefixAndEnclosedString(System.String,System.String@,System.String@,System.Char,System.Char)">
            <summary>
            Splits a text into prefix and something that is enclosed by two given chars. The closing char is searched starting from the end of the string. 
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetNameAndVersion(System.String,System.String@,System.String@)">
            <summary>
            Finds name and version in a string like "MyName (MyVersion)"
            </summary>
            <param name="userInput">The string to parse</param>
            <param name="name">Name, might be the input string</param>
            <param name="version">null if no version found</param>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetNameAndVersion(System.String)">
            <summary>
            Finds name and version in a string like "MyName (MyVersion)"
            </summary>
            <param name="userInput">The string to parse</param>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetCategoryReference(System.String)">
            <summary>
            Returns a CategoryReference for a vague category description. the description may not start with a global category.
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetCategoryReferenceAndWhatEverIsInFront(System.String,System.String@,VL.Model.CategoryReference@)">
            <summary>
            Split a string like "prefix [vageCatDescription]" into "prefix" and a CategoryReference. 
            Use other methods to further parse the prefix depnding on if you're searching for node or type
            </summary>
            <param name="userInput">The user input.</param>
            <param name="prefix">The prefix of the user input.</param>
            <param name="categoryRef">The reference given back. This is a nested category reference and might not be full depending on the user input.</param>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetCategoryAndTypeFromDottedDescription(System.String,System.String@,VL.Model.CategoryReference@)">
            <summary>
            Separates a vague "CatA.CatB.TypeDescription" into a nested CategoryReference and a TypeDescription
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.GetDefinitionAndSpecializationArguments(System.String,System.String@,System.String[]@)">
            <summary>
            Split a node or type specialization into defintion and arguments
            use other methods to further parse the prefix depnding on if you're searching for node or type
            </summary>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidIdentifier(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct format of a-z A-Z 0-9 and some special chars, not starting with number
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidIdentifierWithSpaces(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct format of a-z A-Z 0-9 and some special chars, not starting with a number or spcace
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidCategory(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct format of a-z A-Z 0-9 and some special chars, not starting with a number or dot.
            Used for e.g. for namespaces
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidCategories(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct format of a-z A-Z 0-9 and some special chars, not starting with a number or dot.
            Used for e.g. for namespaces
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidFileName(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct format of a-z A-Z 0-9 and some special chars, not starting with a number or dot.
            Used for e.g. for namespaces
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidIdentifierWithVersion(System.String,System.Boolean)">
            <summary>
            Looks in the string for a version name in round brackets,
            then name and version (if found) are checked for correct identifier format.
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.UserInputParsing.IsValidTypeAnnotation(System.String,System.Boolean)">
            <summary>
            Checks whether a string has the correct chars of a-z A-Z 0-9 &lt;&gt; [] and some special chars, not starting with a space, number, dot, &lt;, &gt;, [, or ].
            And makes shure the form is a valid typ annotation.
            </summary>
            <param name="userInput"></param>
            <param name="allowEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Cci.ExpressionBuilder.GetDefaultValueExpression(Microsoft.Cci.ITypeReference)">
            <summary>
            Prefer to use the overload with our type or you might get unexpected results for compound types.
            Should be fine to use for primitive types.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.Cci.Scope">
            <summary>
            Abstracts over the memory hierachy:
            * The root scope gets provided by the type builder containing all its static fields
            * A method builder introduces a new scope for all its parameters and fields
            * A patch builder introduces a new scope for all its locals
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitStandardConversionExists(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IPlatformType)">
            <summary>
            Returns true if a standard (mostly CLR supplied) implicit conversion is available to convert a value of the given source type to a corresponding value of the given target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitNumericConversionExists(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IPlatformType)">
            <summary>
            Returns true if an implicit numeric conversion from the given source type to the given target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.TypesAreClrAssignmentCompatible(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IPlatformType)">
            <summary>
            Returns true if a CLR supplied implicit reference conversion is available to convert a value of the given source type to a corresponding value of the given target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitTypeParameterConversionExists(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition)">
            <summary>
            Returns true if the source type is a generic parameter with a constraint that requires its runtime value to be of a
            type that derives from the given target type or implements the given target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.UserDefinedConversion(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IName,VL.Lang.Platforms.CIL.HostEnvironment)">
            <summary>
            Returns the most specific user defined conversion operator that can be used to convert a value
            of the source type to a value of the target type. The given conversionName determines whether an explicit or implicit conversion is returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitConversionExists(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,VL.Lang.Platforms.CIL.HostEnvironment)">
            <summary>
            Returns true if an implicit conversion is available to convert a value of the given source type to a corresponding value of the given target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.RemoveNullableWrapper(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IPlatformType)">
            <summary>
            If the given type is an instance if System.Nullable&lt;T&gt;, return the value of T. Otherwise return the given type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitUserDefinedConversionExists(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,VL.Lang.Platforms.CIL.HostEnvironment)">
            <summary>
            Returns true if the source type or target type defines a conversion operator that can be used to convert a value
            of the source type to a value of the target type.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Expr.ImplicitUserDefinedConversion(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.ITypeDefinition,VL.Lang.Platforms.CIL.HostEnvironment)">
            <summary>
            Returns the most specific user defined implicit conversion operator that can be used to convert a value
            of the source type to a value of the target type.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.GlobalAssemblyCache">
            <summary>
            Contains helper routines to query the GAC for the presence and locations of assemblies.
            </summary>
            <remarks>
            Copy of the Microsoft.Cci.GlobalAssemblyCache using a local dictionary as cache in order 
            to speed up lookup time.
            </remarks>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.GlobalAssemblyCache.GetIdentityWithLocation(Microsoft.Cci.AssemblyIdentity,Microsoft.Cci.IMetadataHost)">
            <summary>
            Returns an identity with the original location of the corresponding assembly if available, otherwise returns an identity with the location of the shadow copy.
            If the corresponding assembly is not in the GAC, null is returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Helpers.IsOut(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Wether or not it's an out parameter.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Helpers.DefaultEventMethod(Microsoft.Cci.IMetadataHost,Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IEventDefinition,Microsoft.Cci.IFieldDefinition,Microsoft.Cci.IName,Microsoft.Cci.IMethodDefinition)">
            <summary>
            From http://stackoverflow.com/questions/4959797/short-way-to-write-an-event
            private EventHandler _updateErrorIcons;
            public event EventHandler UpdateErrorIcons
            {
                add
                {
                    EventHandler current, original;
                    do
                    {
                        original = _updateErrorIcons;
                        EventHandler updated = (EventHandler)Delegate.Combine(original, value);
                        current = Interlocked.CompareExchange(ref _updateErrorIcons, updated, original);
                    }
                    while (current != original);
                }
                remove
                {
                    // Same deal, only with Delegate.Remove instead of Delegate.Combine.
                }
            }
            </summary>
            <param name="host"></param>
            <param name="containingType"></param>
            <param name="eventDefinition"></param>
            <param name="backingField"></param>
            <param name="methodName"></param>
            <param name="delegatesMethod"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Helpers.IsSame(Microsoft.Cci.ITypeReference,Microsoft.Cci.ITypeReference)">
            <summary>
            Whether or not two type references resolve to the same type definition.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Helpers.GetMethod(Microsoft.Cci.ITypeDefinition,Microsoft.Cci.IName,Microsoft.Cci.ITypeReference[])">
            <summary>
            Returns a method of the given declaring type that has the given name and that matches the given parameter types.
            If no such method can be found, Dummy.MethodDefinition is returned.
            </summary>
            <remarks>
            Copied from CCI but using resolveTypes = true internally.
            </remarks>
            <param name="declaringType">The type that declares the method to be returned.</param>
            <param name="methodName">The name of the method.</param>
            <param name="parameterTypes">A list of types that should correspond to the parameter types of the returned method.</param>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Helpers.GetMethod(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinitionMember},Microsoft.Cci.IName,Microsoft.Cci.ITypeReference[])">
            <summary>
            Returns the first method, if any, of the given list of type members that has the given name and that matches the given parameter types.
            If no such method can be found, Dummy.MethodDefinition is returned.
            </summary>
            <remarks>
            Copied from CCI but using resolveTypes = true internally.
            </remarks>
            <param name="members">A list of type members.</param>
            <param name="methodName">The name of the method.</param>
            <param name="parameterTypes">A list of types that should correspond to the parameter types of the returned method.</param>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.HostEnvironment">
            <summary>
            The host object provides the framework with a way to call back to the application that is invoking the
            framework in order to obtain environmental specific policy decisions, such as how to resolve a reference to an assembly
            and how to report an error. The host object is also a convenient place to store global state, such as the name table.
            </summary>
            <remarks>Most of the functionality of the host is supplied by the base class. In this case, the base class is specific
            to the AST framework and it support incremental compilation scenarios, hence the SourceEdit part of its name.</remarks>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.HostEnvironment.#ctor">
            <summary>
            Allocates a host object that provides the framework with a way to call back to the application that is invoking the
            framework in order to obtain environmental specific policy decisions, such as how to resolve a reference to an assembly
            and how to report an error. The host object is also a convenient place to store global state, such as the name table.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.HostEnvironment.LoadUnitFrom(System.String)">
            <summary>
            Returns the unit that is stored at the given location, or a dummy unit if no unit exists at that location or if the unit at that location is not accessible.
            </summary>
            <param name="location">A string is expected to be the path to a file that contains the unit to be loaded.</param>
            <remarks>The base class leaves this abstract so that it can be used by applications that do not obtain metadata from
            the file system.</remarks>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.HostEnvironment.ProbeAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            Given the identity of a referenced assembly (but not its location), apply host specific policies for finding the location
            of the referenced assembly.
            Returns an assembly identity that matches the given referenced assembly identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly. It will have been loaded from somewhere and thus
            has a known location, which will typically be probed for the referenced assembly.</param>
            <param name="referencedAssembly">The assembly being referenced. This will not have a location since there is no point in probing
            for the location of an assembly when you already know its location.</param>
            <returns>
            An assembly identity that matches the given referenced assembly identity, but which includes a location.
            If the probe failed to find the location of the referenced assembly, the location will be "unknown://location".
            </returns>
            <remarks>
            Looks for the referenced assembly first in the same directory as the referring unit, then
            in any search paths provided to the constructor, then finally the GAC.
            </remarks>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.HostEnvironment.ResolvingAssemblyReference(Microsoft.Cci.IUnit,Microsoft.Cci.AssemblyIdentity)">
            <summary>
            This method is called when the assembly reference is being resolved and its not already loaded by the Read/Write host.
            </summary>
            <param name="referringUnit">The unit that is referencing the assembly.</param>
            <param name="referencedAssembly">Assembly identity for the assembly being referenced.</param>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.Importer.ImplicitOpAsSubtype">
            <summary>
            Whether or not to translate implicit operators to a subtype relationship.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.Importer.LoadAssembly(System.String)">
            <summary>
            The location can be absolute or relative.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.ImportedCategorizableSymbol.TryGetXMLHelp(System.Xml.Linq.XElement@)">
            <summary>
            Tries to get the original C# XML help for this symbol.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.ModuleSymbolSource.ImportedTypes">
            <summary>
            Gets the imported types, nested types are flat in the list
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.CilCompilation.CreateClrValue(System.Type,VL.Lang.Symbols.DocSymbols,VL.Core.NodeContext)">
            <summary>
            Value creation can have side-effects (calls create of type)
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.CilCompilation.CreateClrValue(VL.Lang.Symbols.IConcreteTypeSymbol,VL.Lang.Symbols.DocSymbols,VL.Core.NodeContext)">
            <summary>
            Value creation can have side-effects (calls create of type)
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.CilCompilation.DefaultClrValue(VL.Lang.Symbols.IConcreteTypeSymbol,VL.Lang.Symbols.DocSymbols)">
            <summary>
            Value creation has no side-effects (does not call create of patch)
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.Platform">
            <summary>
            The Common Intermediate Language (CIL) platform.
            It's main components are:
            - The symbol collector
            - The dynamic and static compilers
            - The reflection emitter
            - The runtime host
            
            On startup it will use the symbol collector to import types and nodes
            from .NET and register them in the central symbol host.
            
            Once the import is done it will start listening for new compilations
            on the post compiler.
            
            Whenever a new post compilation arrives it will trigger the dynamic
            compiler, followed by the reflection emitter. Once the emitter is done
            the runtime host will be notified about the new reflection compilation.
            
            When the runtime host receives a new reflection compilation it will
            integrate it in the running program.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.PluginAttribute">
            <summary>
            Tells VL that it should scan this assembly for INodePlugin and INodeFactory.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IPatchCompiler">
            <summary>
            Defines a set of methods used for generating the target code of a plugin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.Host">
            <summary>
            Returns the CCI host.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.Document">
            <summary>
            Returns the document for which code is emitted currently. Used for symbol location information.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.NodeContext">
            <summary>
            The context to use when creating new instances of VL types.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.NewIdentityMethod">
            <summary>
            The method to call in order to produce a new VLObject identity <see cref="M:VL.Core.VLObject.NewIdentity"/>.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.Instance">
            <summary>
            The reference to the current instance (if any).
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.CurrentBlock">
            <summary>
            The current block of statements.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPatchCompiler.CollectValuesOnStack">
            <summary>
            Whether or not values on the call stack should be collected in case of an exception.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetType(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Gets the CCI type symbol for the given VL type symbol.
            </summary>
            <param name="typeSymbol">The VL type symbol.</param>
            <returns>The CCI type symbol.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetType(System.Type)">
            <summary>
            Gets the CCI type symbol for the given CLR type symbol.
            </summary>
            <param name="clrType">The CLR type symbol.</param>
            <returns>The CCI type symbol.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetReturnType(VL.Lang.Symbols.IPatchSymbol)">
            <summary>
            Gets the CCI type symbol for the outputs of the patch. This is either void, the single output type or a tuple.
            </summary>
            <param name="patch">The patch for which outputs to return a type.</param>
            <returns>Void in case the patch has no outputs, the type of the one single output or a tuple.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetField(VL.Lang.Symbols.IFieldDefinitionSymbol)">
            <summary>
            Gets the CCI field symbol for the given VL field symbol.
            </summary>
            <param name="fieldSymbol">The VL field symbol.</param>
            <returns>The CCI field symbol.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Compile(VL.Lang.Symbols.IPatchSymbol,System.Collections.Generic.List{Microsoft.Cci.IStatement},Microsoft.Cci.IExpression)">
            <summary>
            Compiles the given patch and adds all generated statements to the given statement list. Computed expressions will be remembered in the current scope.
            </summary>
            <param name="patch">The patch to compile.</param>
            <param name="statements">The list of statements to add to.</param>
            <param name="state">The state used for pad reads.</param>
            <returns>A block statement containing the generated statements.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.BeginScope">
            <summary>
            Opens up a new scope. Must be followed by a call to EndScope.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.EndScope">
            <summary>
            Ends the current scope. All the expression computed between this and the last call to Compile will be forgotten.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.CreateLocal(System.String,Microsoft.Cci.ITypeReference)">
            <summary>
            Creates a local variable in the current scope.
            </summary>
            <param name="name">The desired name of the variable. Can be null.</param>
            <param name="type">The type of the variable. Must not be null.</param>
            <returns>The newly created local variable. Note that the variable still needs to be declared or initialized with a local declaration statement.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetExpression(VL.Lang.Symbols.IDataHubSymbol)">
            <summary>
            Gets the already computed expression for the given data hub.
            </summary>
            <param name="hub">The data hub to get the expression for.</param>
            <returns>The computed expression for the given data hub or null if the hub wasn't touched yet.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetExpression(VL.Lang.Symbols.ISlotSymbol)">
            <summary>
            Gets the latest computed expression for the given slot.
            </summary>
            <param name="slot">The slot for which to retrieve the latest computest expression for.</param>
            <returns>The expression or null if the slot wasn't touched yet.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Bind(VL.Lang.Symbols.IDataHubSymbol,Microsoft.Cci.IExpression)">
            <summary>
            Binds the expression to the data hub.
            </summary>
            <param name="hub">The data hub for which the expression will be used for later <see cref="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetExpression(VL.Lang.Symbols.IDataHubSymbol)"/> calls.</param>
            <param name="expression">The expression to bind.</param>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Bind(VL.Lang.Symbols.ISlotSymbol,Microsoft.Cci.IExpression)">
            <summary>
            Binds the expression to the slot.
            </summary>
            <param name="slot">The slot for which the expression will be used for later <see cref="M:VL.Lang.Platforms.CIL.IPatchCompiler.GetExpression(VL.Lang.Symbols.ISlotSymbol)"/> calls.</param>
            <param name="expression">The expression to bind.</param>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Default(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Returns the default value expression of the given type.
            </summary>
            <param name="type">The type for which a default value is required.</param>
            <returns>The default value expression of the given type.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Default(Microsoft.Cci.ITypeReference)">
            <summary>
            Returns the default value expression of the given type.
            </summary>
            <param name="type">The type for which a default value is required.</param>
            <returns>The default value expression of the given type.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Constant(VL.Lang.Symbols.ICompileTimeValueSymbol)">
            <summary>
            Returns a value expression for the given value.
            </summary>
            <param name="value">The value itself.</param>
            <returns>The value as an expression.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPatchCompiler.Call(VL.Lang.Symbols.IOperationDefinitionSymbol,System.Collections.Generic.IReadOnlyDictionary{VL.Lang.Symbols.IPinDefinitionSymbol,Microsoft.Cci.IExpression})">
            <summary>
            Returns an expression which calls the given operation.
            </summary>
            <param name="operation">The operation to call.</param>
            <param name="arguments">The arguments to use for the pins.</param>
            <returns>An expression representing the call to the operation.</returns>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IPinDescription">
            <summary>
            Describes a pin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPinDescription.Name">
            <summary>
            The name of the pin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPinDescription.Kind">
            <summary>
            The kind of the pin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPinDescription.Type">
            <summary>
            The type of the pin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPinDescription.DefaultValue">
            <summary>
            The default value of the pin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPinDescription.Visibility">
            <summary>
            The visibility of the pin.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IPluginHost">
            <summary>
            The host which mediates between the plugin and the internal representation of a node definition.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IPluginHost.CurrentDefinition">
            <summary>
            The plugin as seen by VL.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPluginHost.Instantiate(VL.Lang.Platforms.CIL.INodePlugin)">
            <summary>
            Create a node definition for the given plugin node.
            </summary>
            <param name="plugin">The plugin node create a node definition for.</param>
            <returns>The node definition representing the plugin.</returns>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.INodePlugin">
            <summary>
            A node plugin. Will be instantiated if the assembly has the <see cref="T:VL.Lang.Platforms.CIL.PluginAttribute"/> attribute set. 
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.Name">
            <summary>
            The name of the node.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.Category">
            <summary>
            The category of the node.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.Kind">
            <summary>
            What kind of node definition. Usual choices are AdaptiveRegion, OperationStatefulRegion, ProcessStatefulRegion etc.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.ShowCategory">
            <summary>
            Whether or not to show the category inside the UI.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.Inputs">
            <summary>
            The inputs of the node.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.INodePlugin.Outputs">
            <summary>
            The outputs of the node.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IExpandingPlugin">
            <summary>
            Gives the plugin the ability to inject a new model very early in the compile phase.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IExpandingPlugin.IsPlaceholder">
            <summary>
            Whether or not the plugin expands in a way that parts of the original source code get re-used.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IDelegatesToOtherPlugin">
            <summary>
            Gives the plugin the ability to delegate to another plugin which can then use the information as stored in the model.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IDelegatesToNodeDefinition">
            <summary>
            Gives the plugin the ability to delegate to another node definition.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IEmittingPlugin">
            <summary>
            Gives the plugin the ability to emit target code at the end of the compile phase.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IEmittingPlugin.Emit(VL.Lang.Platforms.CIL.IPatchCompiler,VL.Lang.Symbols.IPatchSymbol,VL.Lang.Symbols.INodeSymbol,System.Collections.Generic.List{Microsoft.Cci.IStatement})">
            <summary>
            Called by backend in order to generate the target code for this plugin.
            </summary>
            <param name="compiler">The patch compiler to be used to compile the internal patches.</param>
            <param name="patch">The current patch which is getting compiled.</param>
            <param name="node">The node application representing the this plugin.</param>
            <param name="statements">The statement list to use for the generated target code.</param>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IPluginWithMessages">
            <summary>
            Gives the plugin the ability to generate messages which will get shown in the patch editor.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IPluginWithMessages.GetMessages(VL.Lang.Symbols.INodeSymbol)">
            <summary>
            The plugin related messages which will be collected and shown to the user.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.IRegionPlugin">
            <summary>
            A region plugin.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.ApplicationKinds">
            <summary>
            The possible options of how this plugin can be applied.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.IsSynchronous">
            <summary>
            Whether or not the patches inside this region are known to execute synchronously.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.ExecutesOnlyOnce">
            <summary>
            Whether or not the patches inside this region are known to execute at most once (like if, switch, etc.).
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.IsAtomic">
            <summary>
            Used by flood fill algorithm. If true all the pins and border control points of this node will be flooded, otherwise the flood fill stops.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.SupportedBorderControlPoints">
            <summary>
            The supported border control points of the region.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.RegionStateType">
            <summary>
            The type parameter which will be replaced by an anonymous type.
            </summary>
        </member>
        <member name="P:VL.Lang.Platforms.CIL.IRegionPlugin.PatchDescription">
            <summary>
            The patch description. Only master/sub is supported for now.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.IRegionPlugin.GetControlPointType(VL.Lang.Symbols.IBorderControlPointSymbol,VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Called when the system needs to know the outer and type of a control point.
            </summary>
            <param name="cp">The control point.</param>
            <param name="innerType">The inner type.</param>
            <returns>The outer type of the control point.</returns>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.INodeFactory">
            <summary>
            In case an assembly has the <see cref="T:VL.Lang.Platforms.CIL.PluginAttribute"/> attribute set VL will scan that
            assembly for node factories and instantiate them once - it expects an implementing class to
            have a constructor of the form ctor(<see cref="T:VL.Lang.Symbols.IPlatform"/> platform).
            Whenever a VL document references such an assembly all its node factories will be asked for
            additional definitions - which can be types or nodes.
            </summary>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.INodeFactory.GetDefinitions(VL.Model.IDocument,System.Collections.Generic.IEnumerable{VL.Lang.Symbols.IDefinitionSymbol})">
            <summary>
            Called for the document which references this assembly.
            </summary>
            <param name="document">The document which references this assembly.</param>
            <param name="patchedDefinitions">The symbols for the user patched definitions. Access is very limited. Stick to name and category only.</param>
            <returns>Additional definitions which shall be included in the document.</returns>
        </member>
        <member name="M:VL.Lang.Platforms.CIL.RuntimeHost.SharedStep">
            <summary>
            keep in sync with vvvv integration runtimehost
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.Vector45">
            <summary>
            Extends the interface list of the vector with the IReadOnly* interfaces introduced in .NET 4.5
            and also adds the Length and Item[i] properties so most of the import mechanism can be re-used
            for the array.
            </summary>
        </member>
        <member name="T:VL.Lang.Platforms.CIL.Matrix45">
            <summary>
            Adds the Length and Item[i] properties so most of the import mechanism can be re-used
            for the array.
            </summary>
        </member>
        <member name="T:VL.Lang.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:VL.Lang.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:VL.Lang.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:VL.Lang.PublicAPI.ISolution.AddPin(System.UInt32,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Adds a pin to a node application.
            </summary>
            <param name="nodeId">The unique id of the node application.</param>
            <param name="pinGroup">The name of the pin group the newly added pin should be part of.</param>
            <param name="pinName">The name of the new pin.</param>
            <param name="isInput">Whether or not the pin is an input or an output.</param>
            <param name="type">The type annotation. For example "Spread&lt;float&gt;". If left empty the generated pin on application side will be generic.</param>
            <returns>A new solution with the newly added pin.</returns>
        </member>
        <member name="M:VL.Lang.PublicAPI.ISolution.RemovePin(System.UInt32,System.String,System.Boolean)">
            <summary>
            Removes a pin from a node application.
            </summary>
            <param name="nodeId">The unique id of the node application.</param>
            <param name="pinName">The name of the pin to remove.</param>
            <param name="isInput">Whether or not the pin is an input or output.</param>
            <returns>A new solution with the pin removed.</returns>
        </member>
        <member name="M:VL.Lang.PublicAPI.ISolution.ModifyPinGroup(System.UInt32,System.String,System.Boolean)">
            <summary>
            Returns a <see cref="T:VL.Lang.PublicAPI.PinGroupBuilder"/> which can be used to modify the given pin group.
            The builder expects all current pins to get added and once finished will synchronize the internal pin group.
            </summary>
            <param name="nodeId">The unique id of the node application.</param>
            <param name="pinGroup">The name of the pin group the returned builder should modify.</param>
            <param name="isInput">Whether or not the group is an input our output group.</param>
            <returns>A <see cref="T:VL.Lang.PublicAPI.PinGroupBuilder"/> to modify the given pin group.</returns>
        </member>
        <member name="M:VL.Lang.PublicAPI.ISolution.SetPinValue(System.UInt32,System.String,System.Object)">
            <summary>
            Sets the value of the given pin.
            </summary>
            <param name="node">The unique id of the node application.</param>
            <param name="pin">The name of the input pin on which the value should get set.</param>
            <param name="value">The value to set.</param>
            <returns>A new solution with the value stored in the pin of the given node.</returns>
        </member>
        <member name="M:VL.Lang.PublicAPI.ISolution.Confirm">
            <summary>
            Make this solution the current one.
            </summary>
        </member>
        <member name="T:VL.Lang.PublicAPI.PinGroupBuilder">
            <summary>
            Modifies a pin group by simply adding pins to it and once finished calling commit on it. The pins will then get synchronized.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.PreCompilation.GetDocumentsInBuildOrder">
            <summary>
            Retrieves the documents in build order. For example CoreLib comes before Skia.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.LocalTypeForwards">
            <summary>
            The type forwards introduced by this document.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.TypeForwards">
            <summary>
            The type forwards from all reachable documents as well as those introduced by this document.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.DocSymbols.GetPlugins">
            <summary>
            Treat referenced plugins as if they were defined in our document (like user created an explicit forward for them)
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.DependencySymbol.Location">
            <summary>
            The location of the dependent file or package. For a file this will be the absolute path, for package just its name.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.DependencySymbol.IsForward">
            <summary>
            Whether or not the dependency should be forwarded to the document referencing this document.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.DependencySymbol.Name">
            <summary>
            The file or package name.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.DependencySymbol.FilePath">
            <summary>
            The absolute path of the dependent file.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.DocSymbols.DependencySymbol.ReferencedDocument">
            <summary>
            The document referenced through this dependency. Can be null.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.DocSymbols.DependencySymbol.GetFilePath(System.String)">
            <summary>
            Computes the file path of this dependency.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.DocSymbols.DocumentDependencySymbol">
            <summary>
            Dependencies to other VL documents (*.vl).
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.DocSymbols.AssemblyDependencySymbol">
            <summary>
            Dependency to assembly.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.IScope">
            <summary>
            Scoped Symbols, currently only supported by documents. If implemented by local constructs the surrounding Scope needs to be extended.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IScope.AllSymbolsInScope">
            <summary>
            All symbols in scope, no assembly symbols
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IScope.PlatformTypes">
            <summary>
            Easy access for commonly used types.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IScope.Platform">
            <summary>
            The platform giving access to backend stuff.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.IScope.GetSymbolSourceForFile(System.String,System.Boolean)">
            <summary>
            Retrieves a symbol source for a file, that only comes with symbols that were defined in that file.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.PatchAndDataflowHelpers.SelectImplementation(VL.Lang.Symbols.INodeDefinitionSymbol,VL.Lang.Symbols.IScope,System.Collections.Generic.IReadOnlyDictionary{VL.Lang.Symbols.ITypeSymbol,VL.Lang.Symbols.ITypeSymbol},VL.Lang.Symbols.INodeDefinitionSymbol[])">
            <summary>
            Tries to find implementation for the given node parameter. Returns the parameter itself if no implementation was found.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.PatchAndDataflowHelpers.GetSubPatchesUsingTheSymbol(VL.Lang.Symbols.IPatchSymbol,VL.Lang.Symbols.ISymbol)">
            <summary>
            Returns all the sub patches which make direct and indirect (inside a region) use of the given symbol.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.CreateValue(VL.Lang.Symbols.ITypeSymbol,VL.Core.NodeContext)">
            <summary>
            Creates a value for of the given type.
            Value creation can have side-effects.
            </summary>
            <param name="type">The type to create a value for.</param>
            <param name="context">The context in which this instance gets created.</param>
            <returns>The default value of the given type.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.DefaultValue(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Creates a value for of the given type.
            Value creation will not have any side-effects.
            </summary>
            <param name="type">The type to create a value for.</param>
            <returns>The default value of the given type.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.GetClrType(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Returns the CLR type used when marshaling a value of that VL type.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.GetVlType(System.Type,VL.Lang.Symbols.IScope)">
            <summary>
            Returns the VL type used when marshaling a value of that CLR type.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.EmitSource(VL.Model.Node)">
            <summary>
            Returns the decompiled source code (if any) of the given type.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ITargetCompilation.WithCompilation(VL.Lang.Symbols.PreCompilation,System.Threading.CancellationToken,System.IProgress{VL.Model.LoadMessage})">
            <summary>
            Returns a new target compilation based on the given pre compilation.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeHost.ImplicitEntryPointInstances">
            <summary>
            Returns runtime instances that stem from documents with entry points like seen in tutorials.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeHost.HostingAppInstances">
            <summary>
            Returns runtime instances that were explicitly created via hosting environment like vvvv
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeHost.Mode">
            <summary>
            Gets or sets the run mode.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.IRuntimeHost.Step">
            <summary>
            Evaluates the next frame.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeHost.Frame">
            <summary>
            Returns the current frame number.
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.FrameCompleted">
            <summary>
            Raised when the evaluation of a frame completed.
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.Updated">
            <summary>
            Raised when the runtime was updated with a new program (hot swap).
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.Started">
            <summary>
            Raised when the runtime started.
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.Stopped">
            <summary>
            Raised when the runtime stopped.
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.ModeChanged">
            <summary>
            Raised when the run mode of the runtime changed.
            </summary>
        </member>
        <member name="E:VL.Lang.Symbols.IRuntimeHost.OnException">
            <summary>
            Raised when an exception occurs.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeInstance.NodeId">
            <summary>
            The node definition this instance is running.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeInstance.RuntimeMessages">
            <summary>
            All the runtime messages of the running instance.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IRuntimeInstance.Object">
            <summary>
            the actual object
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.RuntimeHostExtensions.RuntimeMessages(VL.Lang.Symbols.IRuntimeHost)">
            <summary>
            Returns all the messages of the last frame evaluation.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.RuntimeHostExtensions.ListenTo(VL.Lang.Symbols.IRuntimeHost,VL.Model.Element,System.IObservable{VL.Core.PatchHandle},System.String,VL.Lang.Symbols.SymbolRendering.ElementPart,VL.Core.InstanceFilter)">
            <summary>
            Gets the patch notifications of the given element. Puts the containing patch in DEBUG mode.
            In case the element is a process node all its fragments will be observed.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.ICompoundSymbol.Symbols">
            <summary>
            The symbols of this compound.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.ICompileTimeValueSymbol.Type">
            <summary>
            The type of the value or a dummy if it can't be resolved.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ICompileTimeValueSymbol.GetSerializedValue(VL.Core.IVLFactory)">
            <summary>
            The string or XElement.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.ICompileTimeValueSymbol.ClrValue">
            <summary>
            The value. If null the <see cref="M:VL.Lang.Symbols.ICompileTimeValueSymbol.GetSerializedValue(VL.Core.IVLFactory)"/> needs to be used.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDataHubSymbol.Value">
            <summary>
            The value of the hub if not connected. Returns a dummy if there's none.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeSymbol.TopPatch">
            <summary>
            The patch which contains all the links.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeSymbol.Patches">
            <summary>
            The patches of the region.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchSymbol.IsDefault">
            <summary>
            Whether or not to put yet unassigned symbols onto this patch.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchSymbol.PatchDescription">
            <summary>
            A patch description provided by the containing node - contains additional information on what is allowed or not in the patch.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IConcreteTypeSymbol.CreateValue">
            <summary>
            The operation to call to create a new value of this type. Has exactly one output and one input with the context in which the instance is created. Returns a dummy in case there's none.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IConcreteTypeSymbol.DefaultValue">
            <summary>
            The operation to call to create the default value of this type. Has exactly one output and no inputs. Returns a dummy in case there's none.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IConcreteTypeSymbol.IsBoundToType">
            <summary>
            Whether or not type parameters are used from the parent type definition.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IConcreteTypeSymbol.IsGeneric">
            <summary>
            Whether or not the type parameter list is not empty.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IConcreteTypeSymbol.Rank">
            <summary>
            The rank of the array (if any)
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDefinitionSymbol.Node">
            <summary>
            The node (if any) which lead to this definition. This is usually null for imported types and nodes as well as patched members.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDefinitionSymbol.IsPatched">
            <summary>
            Whether or not this definition has a body and can therefor be emitted.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDefinitionSymbol.DirectlyReferencedDefinitions">
            <summary>
            The fully instantiated definitions referenced directly.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDefinitionSymbol.PlatformTypes">
            <summary>
            Easy access for commonly used types.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDependencySymbol.Location">
            <summary>
            The location of the dependent file or package. For a file this will be the absolute path, for package just its name.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDependencySymbol.IsForward">
            <summary>
            Whether or not the dependency should be forwarded to the document referencing this document.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDependencySymbol.RemoteSymbolSource">
            <summary>
            The remote symbol source or a dummy if it can't be resolved.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDependencySymbol.ReferencedDocument">
            <summary>
            The document referenced through this dependency. Can be null.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IDependencySymbol.FilePath">
            <summary>
            The absolute path of the dependent file.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IFieldDefinitionSymbol.ContainingType">
            <summary>
            The containing type of the field. 
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IFieldDefinitionSymbol.IsManaged">
            <summary>
             Whether or not the field will get managed by the runtime.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IFieldDefinitionSymbol.Slot">
            <summary>
            The slot which lead to this field. Simply a back pointer.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.ApplicationKinds">
            <summary>
            The possible options of how this node definition can be applied.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.RegionIsSynchronous">
            <summary>
            Whether or not the patches inside this region are known to execute synchronously.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.RegionExecutesOnlyOnce">
            <summary>
            Whether or not the patches inside this region are known to execute at most once (like if, switch, etc.).
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.RegionStateType">
            <summary>
            The type to use to manage the state of this stateful region (if used as such). Returns a dummy if statefulness is not supported.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.IsAtomic">
            <summary>
            Use by flood fill algorithm. If true all the pins and border control points of this node will be flooded, otherwise the flood fill stops.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.IsPlaceholder">
            <summary>
            Whether or not this definition is a placeholder for something else. Used by liftings like process nodes or apply pins.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.IsGeneric">
            <summary>
            Whether or not the type parameter list is not empty.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.INodeDefinitionSymbol.IsRecursive">
            <summary>
            Whether or not this node definition is recursive.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IOperationDefinitionSymbol.Body">
            <summary>
            The body of this operation definition. Returns a dummy if it doesn't have one.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.OperationDefinitionExtensions.GetInstanceOperation(VL.Lang.Symbols.IOperationDefinitionSymbol,VL.Lang.Symbols.IScope)">
            <summary>
            Instantiates the operation with its own type parameters.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPinDefinitionSymbol.DefaultValue">
            <summary>
            The default value of the pin or a dummy.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPinDefinitionSymbol.PinInPatch">
            <summary>
            The pin inside the patch which created this definition or a dummy.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IProcessDefinitionSymbol.Initializer">
            <summary>
            Initializes the process. Used during state restore.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IProcessDefinitionSymbol.Runner">
            <summary>
            Runs all the fragments of the process with defaut value arguments. Has one state input and one state output. Gives runtime easy access.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IProcessDefinitionSymbol.StateType">
            <summary>
            The type of the state managed by the process. Returns a dummy if configured in a wrong way.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IProcessDefinitionSymbol.Operations">
            <summary>
            The operations this process is made out of.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.ISymbol.TracingId">
            <summary>
            The id of a source code element this symbol is associated with. Used by target code to insert debug and tracing location information
            which can later be mapped back to source code elements.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.NodeDefinitionSymbol.ShowCategory">
            <summary>
            Display the node category (e.g. the containig type).
            True for operations of product types, extention methods or some special static operations
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.NodeDefinitionSymbol.NodeParameters">
            <summary>
            those are always specializations of adaptive nodes. no implementations. no operations just using adaptive nodes.
            typically distinct. not so for specialized operation definitions (those in a type instance)
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.OperationDefinitionSymbol.ImplementationOf">
            <summary>
            The interface operation or delegate this operation implements.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.Mutable.Symbol">
            <summary>
            base class for the symbolic model
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.Symbol.Parent">
            <summary>
            The parent symbol.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.Symbol.IsUnused">
            <summary>
            Whether or not the symbol is in use. If unused the symbol won't make it into the post compilation.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.Symbol.IsFrozen">
            <summary>
            Whether or not the symbol is frozen. Frozen symbols can't be modified anymore.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.Symbol.IsIntendedToBeShared">
            <summary>
            Whether or not the symbol is intended to be shared by different moments.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.Symbol.Origins">
            <summary>
            Points to the symbols of which this symbol originated from.
            In case the symbol gets removed the origins will also be removed.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.Mutable.NamedSymbol">
            <summary>
            identifieable symbol
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.NamedSymbol.Name">
            <summary>
            The name of this symbol.
            </summary>        
        </member>
        <member name="M:VL.Lang.Symbols.Mutable.NamedSymbol.ToString">
            <summary>
            a default string rendering. also used by debugger
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Mutable.NamedSymbol.GetID">
            <summary>
            called once to compute the (global) ID
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.Mutable.NamedSymbol.FileNameWithExtension">
            <summary>
            a global ID. no ambiguity.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.TypeParameterSymbol">
            <summary>
            a type parameter is an undefined type placeholder. it has some constraints for its application later on.
            atm a GenericNodeReference (= a generic method) or a GenericProductTypeDefinition (= a generic struct or type)
            can have type parameters.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedDataHubSymbol.SourceType">
            <summary>
            Gets the type of outgoing data, e.g. output links
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedDataHubSymbol.SinkType">
            <summary>
            Gets the type of incoming data, e.g. input links
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedPatchPinSymbol.VisibilityInside">
            <summary>
            Whether or not the pin is visible inside of a patch.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedPatchPinSymbol.VisibilityOutside">
            <summary>
            Whether or not the pin is visible on a node application.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.ConcreteTypeSymbol.InstanceType">
            <summary>
            A trivial instantiation of this type.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.TypeAnnotation">
            <summary>
            Represents a type annotation. Consists of the type reference as defined by the user, including the resolve result.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.PatchedSymbolExtensions.CreateProcessRunner(VL.Lang.Symbols.ProcessDefinitionSymbol)">
            <summary>
            Returns an operation which will run all the fragments of the given process. The returned operation has one state input and one state output.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.IPatchedTopLevelDefinitionSymbol">
            <summary>
            A definition which introduces its own type parameters. Doesn't share any with the outer context.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchedConcreteTypeSymbol.SuperTypeAnnotations">
            <summary>
            The super type annotations as definined in the model.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchedNodeSymbol.RawNodeReferenceSymbol">
            <summary>
            The original node reference that lead to the RawNodeDefinition. It is always assigned.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchedNodeSymbol.RawNodeDefinition">
            <summary>
            The initial node definition before any type unification has been done. A dummy if it can't be resolved.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchedNodeSymbol.InstancedNodeDefinition">
            <summary>
            The instantiated node defintion (if the raw definition is generic) before the unification.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.IPatchedNodeSymbol.UnifiedNodeDefinition">
            <summary>
            The node definition after type unification but before selecting the final adaptive implementation.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedNodeSymbol.UserInputs">
            <summary>
            The inputs as defined in the model. Might be incomplete! Use the Inputs property if a complete list as defined by the definition is needed.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedNodeSymbol.UserOutputs">
            <summary>
            The outputs as defined in the model. Might be incomplete! Use the Outputs property if a complete list as defined by the definition is needed.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchedNodeSymbol.UserPins">
            <summary>
            The pins as defined in the model. Might be incomplete! Use the Pins property if a complete list as defined by the definition is needed.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchSymbol.PatchDescription">
            <summary>
            The patch description is used to determine what subpatches and pins are allowed in a patch. 
            In region applications it is provided by the region definition, in operation sub patches it is set if the containing definition implements an interface.
            If there's no patch description a dummy will be returned.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchSymbol.UserPatchDescription">
            <summary>
            The patch description is used to determine what subpatches and pins are allowed in a patch.
            This property differs from the <see cref="P:VL.Lang.Symbols.PatchSymbol.PatchDescription"/> that it will take the expanding node into account (if any) and therefor aligns
            more closely to what the user expects.
            For example a higher order region gets expanded very early in the compile phase so when asking the patch for its description the one from the delegate
            region will be returned and not the one from the higher order lifting.
            </summary>
        </member>
        <member name="P:VL.Lang.Symbols.PatchSymbol.ProxyMap">
            <summary>
            A map of data hub ids from proxy to pin and vice versa. Used for quick proxy lookups.
            In case there're multiple proxies for a pin only the first one will be in the map. Use the DataHub.Proxies property if that information is important.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.IReferenceProvider">
            <summary>
            you can think of several strategies to convert a type into a (serializable) reference pointing to that type
            e.g. you could save only as much as is necessary to resolve to the type (current state, current scope)
            this technique might result in conflicts later on, but has the smallest foot print
            another strategy would be to save as much as possible (all categorization info, the source filename...)
            
            IReferenceProvider abstracts over the used strategy
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.ScopedSymbol">
            <summary>
            Each document (= scope) can have a different set of type forwards. The scoped symbol will ensure that all properties of the wrapped symbol are also scoped.
            As of now scoped symbols are used for imported symbols for which no explicit forward has been defined.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.SymbolExtensions.GetDefaultValue(VL.Lang.Symbols.IDataHubSymbol,System.Boolean)">
            <summary>
            Gets the default value of the pin, the constant value of the pad or the default value of the hub's type.
            </summary>
        </member>
        <member name="T:VL.Lang.Symbols.SymbolRendering">
            <summary>
            configure how symbols are rendered.
            you might want to show type arguments, categorization, 
            even normal arguments to distinguish overloaded node definitions
            you might want to see internal ids, in a local scope or global,
            you might want to see some of those features (like category) only in case of ambiguity 
            
            so SymbolRendering is there to help configure your rendering
            the ID of a symbol is the result of a symbol rendering configuration
            SymbolRendering doesnt do much by itself
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.ISymbolSource.SymbolSourceForCategoryOrDefault(System.String)">
            <summary>
            Yields only symbols in the category if supported. Otherwise yields original symbol source. When implemented this may help performance. 
            Callers must be aware that it may not be implemented and still filter for category on resulting symbols.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsPrimitive(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type is one of the primitive types. Primitive types are:
            bool, int32, int64, float32, float64 and string
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type is one of the primitive types.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsParameterized(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type or any of its containing types are generic type definitions - their generic type parameter list is not empty.
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type or any of its containing types is a generic type definition.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsOpen(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type is a type parameter or contains a type parameter in its arguments.
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type is or contains a type parameter.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsOpen(VL.Lang.Symbols.IConcreteTypeSymbol)">
            <summary>
            Whether or not the type or one of its parents is a generic type definition or it contains type parameters in its arguments.
            </summary>
            <param name="concreteType">The type to check.</param>
            <returns>True if the type contains any type parameters.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsClosed(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type is not a type parameter and doesn't contain a type parameter in its arguments.
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type is not a type parameter and does not contain any in its arguments.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsImmutable(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type is immutable. A type is immutable if its definition and all its arguments
            are marked as such. Type parameters are assumed to be immutable during this check.
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type and all its arguments are immutable.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsDeepImmutable(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            Whether or not the type is deep immutable. Note that this check is rather expensive and should get cached in the type symbol itself.
            TODO: Do this once the new imports branch is on develop.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsPatched(VL.Lang.Symbols.IDefinitionSymbol)">
            <summary>
            Whether or not the symbol is patched.
            </summary>
            <param name="definition">The symbol to check.</param>
            <returns>True if the symbol is patched.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.IsForwardOperation(VL.Lang.Symbols.IDefinitionSymbol)">
            <summary>
            Determines whether this definition symbol is a forward operation definition.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.HasPatchedDefinition(VL.Model.Node,System.Boolean)">
            <summary>
            Determines whether the node has a patched definition.
            </summary>
            <param name="node">The node to check.</param>
            <param name="includeTrivialImports">if set to <c>true</c> trivial imports and process node definitions of forward types will also return true.</param>
        </member>
        <member name="M:VL.Lang.Symbols.TypeExtensions.GetInstanceType(VL.Lang.Symbols.IConcreteTypeSymbol,VL.Lang.Symbols.IScope)">
            <summary>
            Instantiates the type with its own type parameters.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeUnification.CheckImmutabilityAndTypeClasses_Then_Substitute(VL.Lang.Symbols.ITypeParameterSymbol,VL.Lang.Symbols.ITypeSymbol,System.Collections.Generic.IEnumerable{VL.Lang.Symbols.TypeConstraint})">
            <summary>
            you made your decision. now replace typeParameter with otherType.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeUnification.Substitute(System.Collections.Generic.List{VL.Lang.Symbols.TypeConstraint},VL.Lang.Symbols.TypeMapping,System.Boolean)">
            <summary>
            Substitutes each type x in stack with type y.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.TypeUnification.Substitute(System.Collections.Generic.Stack{VL.Lang.Symbols.TypeMapping},VL.Lang.Symbols.TypeMapping,System.Boolean)">
            <summary>
            Substitutes each type x in stack with type y.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Values.Convert``1(System.Object,VL.Lang.Symbols.IScope)">
            <summary>
            Converts the value to the destination type. If conversion is not possible the default value as seen by VL will be returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Values.Convert(System.Object,System.Type,VL.Lang.Symbols.IScope)">
            <summary>
            Converts the value to the destination type. If conversion is not possible the default value as seen by VL will be returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Values.Convert``1(System.Object,VL.Core.IVLFactory)">
            <summary>
            Converts the value to the destination type. If conversion is not possible the default value as seen by VL will be returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Values.Convert(System.Object,System.Type,VL.Core.IVLFactory)">
            <summary>
            Converts the value to the destination type. If conversion is not possible the default value as seen by VL will be returned.
            </summary>
        </member>
        <member name="M:VL.Lang.Symbols.Values.GetNiceName(System.Reflection.FieldInfo)">
            <summary>
            Converts "&lt;PropertyName&gt;k__BackingField" to "PropertyName"
            </summary>
            <param name="fieldInfo">The field information.</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lang.Symbols.Copiers.DeepCopy``1(``0,System.Collections.Generic.Dictionary{VL.Lang.Symbols.ISymbol,VL.Lang.Symbols.ISymbol},System.Collections.Generic.Dictionary{VL.Lang.Symbols.ISymbol,VL.Lang.Symbols.ISymbol})">
            <summary>
            Makes a deep copy of the given symbol.
            </summary>
            <typeparam name="TSymbol">The type of symbol.</typeparam>
            <param name="symbol">The symbol to make a deep copy of.</param>
            <param name="copies"></param>
            <param name="substitutions"></param>
            <returns>The newly created copy.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.Copiers.Substitute``1(``0,System.Collections.Generic.Dictionary{VL.Lang.Symbols.ISymbol,VL.Lang.Symbols.ISymbol})">
            <summary>
            Tries to apply the substitutions on the given symbol. Will only work if the symbols are mutable.
            </summary>
            <typeparam name="TSymbol">The type of the symbol.</typeparam>
            <param name="symbol">The symbol to try to apply the substiutions on.</param>
            <param name="substitutions">A map of symbol substitutions.</param>
            <returns>The same symbol with the substitutions applied.</returns>
        </member>
        <member name="M:VL.Lang.Symbols.Copiers.Copy(VL.Model.IPin,VL.Model.ICompound)">
            <summary>
            Creates a mutable copy of the given pin. The pin's identity will not be copied. Only the tracing id will be set.
            </summary>
            <param name="pin">The pin to copy.</param>
            <param name="parent">The parent for the copied pin.</param>
            <returns>A mutable copy of the pin.</returns>
        </member>
        <member name="T:VL.Lang.TestSession">
            <summary>
            Used by cleanup tool and unit tests so both work on the same set of documents.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Name">
            <summary>
            The Name to be displayed in the menu.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Tooltip">
            <summary>
            The Tooltip to be displayed in the menu.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.ShortcutKeys">
            <summary>
            The Keys to be pressed in order to trigger the Click method.
            </summary>
        </member>
        <member name="M:VL.Lang.Menu.IMenuEntry.Click">
            <summary>
            Gets executed if the menu entry is clicked by the user or
            the keys matching the KeyData property are pressed.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Enabled">
            <summary>
            Whether this entry is enabled or disabled.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Visible">
            <summary>
            Whether this entry is visible in a menu.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.ShowExpander">
            <summary>
            Whether this entry shows the expander.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Checked">
            <summary>
            Whether this entry is checked or not. This property should be ignored if null.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Entries">
            <summary>
            Gets all the sub entries (if any).
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.ContextEntries">
            <summary>
            Gets all the context entries (if any).
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.Tag">
            <summary>
            Allows an arbitrary object to be attached to the menuentry
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.HasError">
            <summary>
            Whether this entry has an error and is to be drawn in red.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuEntry.ContainsShortcutKeys">
            <summary>
            Whether or not this menu item or any of its sub entries can be triggered by a short cut key.
            </summary>
        </member>
        <member name="P:VL.Lang.Menu.IMenuProvider.MenuEntries">
            <summary>
            Returns all the menu entries this menu is composed of.
            </summary>
        </member>
        <member name="T:VL.Lang.Menu.MenuEntry">
            <summary>
            Abstract implemention of IMenuEntry.
            </summary>
        </member>
        <member name="T:VL.Lang.Menu.MenuSeparator">
            <summary>
            A MenuSeparator should be rendered by a viewer in a way to reflect the
            separation of two menu entries.
            </summary>
        </member>
        <member name="T:VL.Core.RefCountedDictionary`2">
            <summary>
            A dictinary that keeps track of how many instances per key are added or removed.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <seealso cref="T:System.Collections.Generic.Dictionary`2" />
        </member>
        <member name="M:VL.Core.RefCountedDictionary`2.GetRefCount(`0)">
            <summary>
            Gets the reference count of a specified key, 0 if no entry exists.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:VL.Core.RefCountedDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be null for reference types.</param>
        </member>
        <member name="M:VL.Core.RefCountedDictionary`2.Remove(`0)">
            <summary>
            Removes the value with the specified key from the <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            true if the element is successfully found and removed; otherwise, false.  This method returns false if <paramref name="key" /> is not found in the <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </returns>
        </member>
        <member name="F:VL.Core.Dialogs.BaseDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VL.Core.Dialogs.BaseDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:VL.Core.Dialogs.BaseDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:VL.Core.Dialogs.NameAndTypeDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VL.Core.Dialogs.NameAndTypeDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:VL.Core.Dialogs.NameAndTypeDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:VL.Core.Dialogs.NameDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VL.Core.Dialogs.NameDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:VL.Core.Dialogs.NameDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:VL.Core.Dialogs.NamespaceNameDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:VL.Core.Dialogs.NamespaceNameDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:VL.Core.Dialogs.NamespaceNameDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:VL.Core.CommandLineArguments.NewInstanceAllowed">
            <summary>
            Gets a value indicating whether a new instance is allowed to open.
            It checks for the '-m' or '--allowmultiple' commandline arg and whether another instance is already running.
            </summary>
        </member>
        <member name="P:VL.Model.Element.Parent">
            <summary>
            The parent container element.
            </summary>
        </member>
        <member name="P:VL.Model.Element.Previous">
            <summary>
            Pointer to the same element in the previous snapshot. Only used by document in order to safe disk accesses for its dependencies.
            </summary>
        </member>
        <member name="P:VL.Model.Element.SaveParent">
            <summary>
            The parent container element. (or self as Container if parent is null)
            </summary>        
        </member>
        <member name="P:VL.Model.Element.Identity">
            <summary>
            The identity of this element inside this session.
            </summary>
        </member>
        <member name="P:VL.Model.Element.SerializedId">
            <summary>
            The serialized identity of this element. Persistent as soon as an element gets written to disk.
            </summary>
        </member>
        <member name="P:VL.Model.Element.Root">
            <summary>
            The root container element. Usually the solution.
            </summary>
        </member>
        <member name="P:VL.Model.Element.Document">
            <summary>
            The document this element is contained in (if any).
            </summary>
        </member>
        <member name="P:VL.Model.Element.Solution">
            <summary>
            The solution this element is a part of.
            </summary>
        </member>
        <member name="P:VL.Model.Element.Ancestors">
            <summary>
            All the parent container elements.
            </summary>
        </member>
        <member name="M:VL.Model.Element.GetAncestorsUpToDefinition">
            <summary>
            All the ancestors up to and including the definition.
            </summary>
        </member>
        <member name="P:VL.Model.Element.PatchDepth">
            <summary>
            Gets the patch depth of this Element. Jumping over subpatches.
            If this Element is a Patch it will not be counted.
            </summary>
        </member>
        <member name="P:VL.Model.Element.PatchDepthWithSelf">
            <summary>
            Gets the patch depth of this Element. Jumping over subpatches.
            If this Element is a Patch it will count.
            </summary>
        </member>
        <member name="P:VL.Model.Element.DefinitionDepth">
            <summary>
            Gets the definition depth of this Element.
            If this Element is a definition it will not be counted.
            </summary>
        </member>
        <member name="P:VL.Model.Element.DefinitionDepthWithSelf">
            <summary>
            Gets the definition depth of this Element.
            If this Element is a definition it will count.
            </summary>
        </member>
        <member name="M:VL.Model.Element.GetNewElement``1(``0)">
            <summary>
            Retrieves the element with the same identity as the given element from the current snapshot. Returns null if the element is not present anymore.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ContainingSuperPatches">
            <summary>
            Returns all sub or indy patches that this element is part of until hitting a definition.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ContainingPatches">
            <summary>
            Returns all sub or indy patches that this element is directly part of.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ContainingTopPatch">
            <summary>
            Gets the patch of the next definition up the hierarchy that contains this element.
            </summary>
        </member>
        <member name="P:VL.Model.Element.MergeId">
            <summary>
            Used during copy and paste to find other elements to merge with.
            </summary>
        </member>
        <member name="P:VL.Model.Element.IsShallowCompound">
            <summary>
            Whether or not this element shall be considered shallow during a merge operation.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ParentCanvas">
            <summary>
            The first canvas when traversing up the ancestors.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ParentNode">
            <summary>
            The first node when traversing up the ancestors.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ParentPatch">
            <summary>
            The first patch when traversing up the ancestors.
            </summary>
        </member>
        <member name="P:VL.Model.Element.ParentDefinition">
            <summary>
            The first type or node definition when traversing up the ancestors. Can be null!
            </summary>
        </member>
        <member name="P:VL.Model.Compound.ActualChildren">
            <summary>
            Due to the nature of our canvas (seperating elements in a visual way only) a compound can have more children than
            actually seen on screen. Therefor this property returns all the actual children of a compound.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetDescendent``1(VL.Model.ElementId)">
            <summary>
            Returns the element with the given identity. Even though results get cached performance is rather poor.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetElementFromSymbol(VL.Lang.Symbols.ISymbol)">
            <summary>
            Fetches the corresponding model element for the given symbol. Returns null if it can't be found.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetDocument(System.UInt32)">
            <summary>
            Retrieves the document with the given identity from this solution. Returns null if the id can't be found.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetTopLevelDefinition(VL.Model.NodeId)">
            <summary>
            Retrieves the node definition with the given identity from this solution. Returns null if the id can't be found.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetNewElement``1(``0)">
            <summary>
            Retrieves the element with the same identity as the given element from this solution. Returns null if the element is not present anymore.
            </summary>
        </member>
        <member name="M:VL.Model.Solution.GetOrAddDocument(System.String,System.Boolean,System.Boolean)">
            <summary>
            If the given file path exists on disk, the document and all its dependencies will be
            loaded and added to the solution, otherwise a new document will be created.
            </summary>
            <param name="filePath">The path to the document.</param>
            <param name="createNew">Whether or not to create a new document if it can't be found at the specified path.</param>
            <param name="loadDependencies">Whether to load the dependent documents.</param>
            <returns>The newly added document.</returns>
        </member>
        <member name="M:VL.Model.Solution.GetOrAddDocument(System.String,System.Boolean,VL.Lang.Symbols.Category,System.Boolean)">
            <summary>
            If the given file path exists on disk, the document and all its dependencies will be
            loaded and added to the solution, otherwise a new document will be created.
            </summary>
            <param name="filePath">The path to the document.</param>
            <param name="createNew">Whether or not to create a new document if it can't be found at the specified path.</param>
            <param name="defaultCategory">The default category for all the definitions placed in this newly created document.</param>
            <param name="loadDependencies">Whether to load the dependent documents.</param>
            <returns>The newly added document.</returns>
        </member>
        <member name="M:VL.Model.Document.SerializeTo(System.IO.Stream,System.String)">
            <summary>
            Serializes the document into the given stream. The file path is used to make paths to dependent documents relative.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="filePath">The path to make dependent documents relative to.</param>
        </member>
        <member name="M:VL.Model.Document.SaveTo(System.String)">
            <summary>
            Internal method to save document to a specific location. Throws an exception when something goes wrong, e.g. file access.
            Used for SaveAs and auto backup.
            </summary>
            <param name="filePath">The file path.</param>
            <returns></returns>
        </member>
        <member name="P:VL.Model.Dependency.Location">
            <summary>
            The location of the dependent file or package. For a file this will be the absolute path, for package just its name.
            </summary>
        </member>
        <member name="P:VL.Model.Dependency.IsForward">
            <summary>
            Whether or not the dependency should be forwarded to the document referencing this document.
            </summary>
        </member>
        <member name="P:VL.Model.Dependency.Name">
            <summary>
            The file or package name.
            </summary>
        </member>
        <member name="P:VL.Model.Dependency.FilePath">
            <summary>
            The absolute path of the dependent file.
            </summary>
        </member>
        <member name="P:VL.Model.Dependency.ReferencedDocument">
            <summary>
            The document referenced through this dependency. Can be null.
            </summary>
        </member>
        <member name="M:VL.Model.Dependency.GetFilePath(System.String)">
            <summary>
            Computes the file path of this dependency.
            </summary>
        </member>
        <member name="M:VL.Model.Dependency.GetReferencedDocumentFilePath">
            <summary>
            Returns a solution with all the referenced documents loaded.
            </summary>
        </member>
        <member name="T:VL.Model.DocumentDependency">
            <summary>
            Dependencies to other VL documents (*.vl).
            </summary>
        </member>
        <member name="T:VL.Model.PlatformDependency">
            <summary>
            Dependencies to target platform specific files (like *.dll).
            </summary>
        </member>
        <member name="T:VL.Model.Canvas">
            <summary>
            A canvas is a compound used to visually seperate elements, but not logically. It does not introduce a new scope.
            All its children have to be treated as if they'd be in the parent children list of the canvas.
            </summary>
        </member>
        <member name="P:VL.Model.Canvas.IsDefinitionCanvas">
            <summary>
            Whether or not this canvas belongs to the parent type definition or document. Such canvases do not have a position.
            </summary>
        </member>
        <member name="M:VL.Model.Canvas.WithPosition(VL.Model.Point2)">
            <summary>
            Returns a new canvas with the given position. If it is the type definition canvas the same instance will be returned.
            </summary>
        </member>
        <member name="T:VL.Model.Link">
            <summary>
            A link between control points. The parent compound should be chosen in
            such a way that it is the most nested one out of all the ancestor 
            compounds of the control points this link connects. This way we get a
            very fine grained difference between element trees later on.
            </summary>
        </member>
        <member name="P:VL.Model.Link.ContainingPatch">
            <summary>
            Gets the containing patch of sink or source if available, otherwise next patch up the hiearchy.
            </summary>
        </member>
        <member name="T:VL.Model.Commands">
            <summary>
            Collection of higher level model modifications, 
            mostly used by the interaction handlers or the context menu entries
            </summary>
        </member>
        <member name="M:VL.Model.Commands.RemoveAndReplaceHubOfLink(VL.Model.Link,VL.Model.DataHubId,VL.Model.DataHub)">
            <summary>
            Replaces a data hub in a link and deletes the replaced one.
            Used in connection handler to replace the temp control point under the mouse with the final datahub.
            </summary>
            <param name="tempLink">The link to edit</param>
            <param name="hubToRemove">The hub to replace</param>
            <param name="newHub">The new hub</param>
            <returns>
            The new link
            </returns>
        </member>
        <member name="M:VL.Model.Commands.ReplaceHubOfLink(VL.Model.Link,VL.Model.DataHubId,VL.Model.DataHub)">
            <summary>
            Replaces a data hub in a link
            </summary>
            <param name="tempLink">The link to edit</param>
            <param name="hubToReplace">The hub to replace</param>
            <param name="newHub">The new hub</param>
            <returns>
            The new link
            </returns>
        </member>
        <member name="M:VL.Model.Commands.ReplaceWithDelegate(VL.Model.DataHub,VL.Lang.Symbols.IConcreteTypeSymbol)">
            <summary>
            Replaces the with delegate.
            </summary>
            <param name="dataHub">The data hub.</param>
            <param name="delType">Type of the delete.</param>
            <returns></returns>
        </member>
        <member name="M:VL.Model.Commands.InsertPadIntoLink(VL.Model.Link,VL.Model.Pad)">
            <summary>
            Inserts the pad into a link.
            </summary>
            <param name="link">The link</param>
            <param name="pad">The pad</param>
            <returns>The new link between the pad and sink of the original link</returns>
        </member>
        <member name="M:VL.Model.Commands.AddHubToLink(VL.Model.Link,VL.Model.DataHub,System.Boolean,System.Boolean)">
            <summary>
            Adds a pad into a link as source or sink
            </summary>
            <param name="link">The link.</param>
            <param name="hub">The pad.</param>
            <param name="sinkToSource">Whether the link is going from sink to source.</param>
            <param name="deleteReplacedHub">Whether to deleted the replaced hub.</param>
            <returns>The new link between the pad and sink of the original link</returns>
        </member>
        <member name="M:VL.Model.Commands.InsertNodeIntoLink(VL.Model.Link,VL.Model.Node,VL.Model.Link@,VL.Model.Link@)">
            <summary>
            Inserts the node into a link.
            </summary>
            <param name="link">The link</param>
            <param name="node">The node</param>
            <param name="inLink">The link into the node, null if no matching input pin was found</param>
            <param name="outLink">The link out of the node, null if no matching output pin was found</param>
        </member>
        <member name="M:VL.Model.Commands.AddNodeToLink(VL.Model.Link,VL.Model.Node,VL.Model.Link@,System.Boolean,System.Boolean)">
            <summary>
            Add node to end of link.
            </summary>
            <param name="link">The link.</param>
            <param name="node">The node.</param>
            <param name="newLink">The link out of the node, null if no matching output pin was found.</param>
            <param name="sinkToSource">Whether the link goes form sink to source.</param>
            <param name="deleteReplacedHub">Whether to delete the replaced hub.</param>
        </member>
        <member name="M:VL.Model.Commands.AddCrossLinkPad(VL.Model.Link,VL.Model.Point2,VL.Model.Canvas,VL.Model.Patch)">
            <summary>
            Adds an anonymous Pad into a link
            </summary>
            <param name="tempLink">The cross link</param>
            <param name="position">The center position for the new pad</param>
            <param name="canvas">The canvas</param>
            <param name="targetPatch">The target patch</param>
            <returns>
            The newly created pad
            </returns>
        </member>
        <member name="P:VL.Model.ControlPoint.IsLinkPoint">
            <summary>
            Whether or not this control point is just a point in the middle of a link.
            </summary>
        </member>
        <member name="P:VL.Model.ControlPoint.IsProxy">
            <summary>
            Whether or not this control point is a proxy for a signature hub.
            So it has an incoming or outgoing reference link.
            </summary>
        </member>
        <member name="P:VL.Model.DataHub.Links">
            <summary>
            Returns all the links which connect to this data hub.
            </summary>
        </member>
        <member name="P:VL.Model.DataHub.Proxies">
            <summary>
            Returns all the proxies connected to this hub via reference links.
            </summary>
        </member>
        <member name="P:VL.Model.DataHub.Proxy">
            <summary>
            Returns the first proxy connected to this hub or null.
            </summary>
        </member>
        <member name="P:VL.Model.DataHub.IsSynchronous">
            <summary>
            Whether or not data is only available in one specific moment. Pads and state outputs of process nodes will return false here.
            </summary>
        </member>
        <member name="P:VL.Model.Node.IsOperationForward">
            <summary>
            Whether or not this is a pure operation forward meaning there're only pins with no type annotations and a single node which auto connects.
            </summary>
        </member>
        <member name="P:VL.Model.Node.Patches">
            <summary>
            All the node's patches. Should a master patch exist it's the first one. Can also be checked per patch with PatchTopology property.
            </summary>
        </member>
        <member name="P:VL.Model.Node.SinglePatch">
            <summary>
            Nearly all nodes have one patch. Exceptions are Switch and HigherOrder regions which have many independent patches and will return null here.
            </summary>
        </member>
        <member name="P:VL.Model.Node.InnerCanvas">
            <summary>
            The inner canvas of this type definition or null if the node is not a type defintion.
            </summary>
        </member>
        <member name="P:VL.Model.Node.DefaultPatch">
            <summary>
            Gets the default sub or indy patch of the node or null
            </summary>
        </member>
        <member name="P:VL.Model.Node.ExplicitBounds">
            <summary>
            User set bounds.
            This is used by the view as the minimal region bounds. 
            If elements inside the region need more space the view will draw the region bigger.
            </summary>
        </member>
        <member name="M:VL.Model.Node.WithBounds(VL.Model.Rectangle2,System.Boolean)">
            <summary>
            Typically you want to set explicit values. 
            Only the StoreSettings in the view should really set bounds implicitly (these will not be saved and therefore reduce git problems)
            </summary>
        </member>
        <member name="F:VL.Model.Patch.Dummy">
            <summary>
            Returns a dummy patch. Use only in temporary solutions!
            </summary>
        </member>
        <member name="P:VL.Model.Patch.EligibleFragmentOperations">
            <summary>
            Returns all the operations which are eligible to be selected in the process definition.
            These are all the layer and region operations except for Destroy.
            </summary>
        </member>
        <member name="P:VL.Model.Patch.Canvases">
            <summary>
            Gets the canvases. Subpatches return the ones of their master patch.
            </summary>
        </member>
        <member name="P:VL.Model.Patch.IsForward">
            <summary>
            Whether or not this patch contains only one node which forwards its pins.
            </summary>
        </member>
        <member name="P:VL.Model.Patch.ProxyMap">
            <summary>
            A map of data hub ids from proxy to pin and vice versa. Used for quick proxy lookups.
            In case there're multiple proxies for a pin only the first one will be in the map. Use the DataHub.Proxies property if that information is important.
            </summary>
        </member>
        <member name="M:VL.Model.Patch.AddOverlay(VL.Model.Rectangle2,VL.Model.Canvas,System.Boolean,System.String,VL.Model.Point2,VL.Model.CursorStyle,System.Nullable{System.Drawing.Color})">
            <summary>
            Creates an overlay which can be used for screenshots
            </summary>
            <param name="bounds"></param>
            <param name="canvas"></param>
            <param name="inViewSpace"></param>
            <param name="name">If not specified overlay is anonymous. It can be named later by the user.</param>
            <param name="cursorPosition">If not specified no cursor will show up in a screenshot of that region.</param>
            <param name="cursorStyle">If not specified no cursor will show up in a screenshot of that region.</param>
            <param name="fillColor">If not specified the user gets an Overlay with a themable Color. The UI should check for null and if null fallback to catalog lookup.</param>
            <returns></returns>
        </member>
        <member name="P:VL.Model.Pin.IsInput">
            <summary>
            Gets a value indicating whether this instance is an input pin.
            Check whether you want know IsSink instead.
            </summary>
        </member>
        <member name="P:VL.Model.Pin.IsOutput">
            <summary>
            Gets a value indicating whether this instance is an output pin.
            Check whether you want know IsSource instead.
            </summary>
        </member>
        <member name="M:VL.Model.Pin.WithBounds(VL.Model.Rectangle2,System.Boolean)">
            <summary>
            Returns a new pin with the given bounds if the pin has no proxy. Otherwise the same instance will be returned.
            </summary>
        </member>
        <member name="P:VL.Model.Pin.IsSink">
            <summary>
            Gets a value indicating whether this instance is a data sink in a patch.
            </summary>
        </member>
        <member name="P:VL.Model.Pin.IsSource">
            <summary>
            Gets a value indicating whether this instance is a data source in a patch.
            </summary>
        </member>
        <member name="T:VL.Model.Slot">
            <summary>
            Slots are accessed by pads.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc51">
            <summary>
            Removes the bounds from all pins except those inside of a loop.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc57">
            <summary>
            Sets the ForwardAllNodesOfTypeDefinition explicitly to false.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc58">
            <summary>
            Sets Node.Name to null for applications
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc60_ForwardPinToAutoConnect">
            <summary>
            Changing from pin forwarding to auto connect (issue #3152)
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc62">
            <summary>
            Looks up unresolvable VL dependencies in packages (issue #2932 and #3515)
            </summary>
        </member>
        <member name="T:VL.Model.Internal.FromDoc79">
            <summary>
            Looks up unresolvable VL dependencies in packages (issue #2932 and #3515)
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Diff.Path">
            <summary>
            Top id points to the modified leave.
            </summary>
        </member>
        <member name="M:VL.Model.Internal.DiffExtensions.Apply``1(``0,System.Collections.Immutable.ImmutableArray{VL.Model.Internal.Diff},System.Boolean)">
            <summary>
            Applies the diffs (if possible) on the compound. Note that not all properties are implemented yet.
            See <see cref="M:VL.Model.Internal.Element.ApplyInternal(VL.Model.Internal.Diff,System.Boolean)"/> method.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.Element">
            <summary>
            A leaf in our green tree.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Element.serializedId">
            <summary>
            Used to identify elements inside a serialized stream. Will stay the same across
            several serializations.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Element.mergeId">
            <summary>
            Used during copy and paste to find other elements to merge with.
            </summary>
        </member>
        <member name="M:VL.Model.Internal.Element.CreateRed(VL.Model.Element)">
            <summary>
            Creates a red node out of this green node.
            </summary>
            <param name="previous">The previous red node (if any). Could be used to re-use certain cached properties.</param>
            <returns>The newly created red node.</returns>
        </member>
        <member name="M:VL.Model.Internal.Element.SerializeTo(System.IO.Stream,System.String)">
            <summary>
            Serializes the document into the given stream. The file path is used to make paths to dependent documents relative.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="documentPath">The path to make dependent documents relative to.</param>
        </member>
        <member name="P:VL.Model.Internal.Element.MergeId">
            <summary>
            Used during copy and paste to find other elements to merge with.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Element.SerializedId">
            <summary>
            Used to identify elements inside a serialized stream. Will stay the same across
            several serializations.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.Compound">
            <summary>
            A node in our green tree.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Document.authors">
            <summary>
            A comma separated list of authors who wrote this document.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Document.credits">
            <summary>
            Credits to third party code used in this document.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Document.licenseUrl">
            <summary>
            The URL to the license.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Document.projectUrl">
            <summary>
            The URL to the project (if any).
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Document.Authors">
            <summary>
            A comma separated list of authors who wrote this document.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Document.Credits">
            <summary>
            Credits to third party code used in this document.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Document.LicenseUrl">
            <summary>
            The URL to the license.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Document.ProjectUrl">
            <summary>
            The URL to the project (if any).
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Dependency.location">
            <summary>
            A unix style relative path which will be used to determine the absolute path
            of the dependent file.
            In case the string starts with a '.' character the lookup will be relative
            to the owner document.
            Otherwise it will be relative to the context specific dependency paths determined
            by the ProbeFile method.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Dependency.Location">
            <summary>
            A unix style relative path which will be used to determine the absolute path
            of the dependent file.
            In case the string starts with a '.' character the lookup will be relative
            to the owner document.
            Otherwise it will be relative to the context specific dependency paths determined
            by the ProbeFile method.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.DocumentDependency">
            <summary>
            Dependencies to other VL documents (*.vl).
            They use VLProject.ProbeFile to determine the full path of a dependency.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.PlatformDependency">
            <summary>
            Dependencies to target platform specific files (like *.dll).
            They use IPlatform.ProbeFile to determine the full path of a dependency.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.NugetDependency">
            <summary>
            Dependency to a NuGet package.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.Canvas">
            <summary>
            A canvas is a compound used to visually seperate elements, but not logically. It does not introduce a new scope.
            All its children have to be treated as if they'd be in the parent children list of the canvas.
            </summary>
        </member>
        <member name="T:VL.Model.Internal.Link">
            <summary>
            A link connects control points.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.NodeOrPatch.summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.NodeOrPatch.remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.NodeOrPatch.tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.NodeOrPatch.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.NodeOrPatch.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.NodeOrPatch.Tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Pin.defaultValue">
            <summary>
            The default value of the pin as string or XElement.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Pin.summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Pin.remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Pin.DefaultValue">
            <summary>
            The default value of the pin as string or XElement.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Pin.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Pin.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Pad.value">
            <summary>
            The value of the pad as string or XElement.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Pad.Value">
            <summary>
            The value of the pad as string or XElement.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Slot.value">
            <summary>
            The value of the slot as string or XElement.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Slot.summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Slot.remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="F:VL.Model.Internal.Slot.tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Slot.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Slot.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Slot.Tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="P:VL.Model.Internal.Slot.Value">
            <summary>
            The value of the slot as string or XElement.
            </summary>
        </member>
        <member name="M:VL.Model.Internal.ModelExtensions.UpdateDescendents``2(``0,System.Func{``1,VL.Model.Internal.Compound,System.Object},System.Func{VL.Model.Internal.Compound,VL.Model.Internal.Compound})">
            <summary>
            Updates all the descendants of the container with the given element type from top to bottom.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TElement">The type of descendants for which to apply the update function.</typeparam>
            <param name="container">The container to update.</param>
            <param name="update">The update function. Either return null to delete the descendant or one or many elements to replace it.</param>
            <param name="updateAfterChildUpdate">Called after a child has been updated.</param>
            <returns>A new container if any descendent was indeed updated.</returns>
        </member>
        <member name="M:VL.Model.DataHubExtensions.Touch``1(``0)">
            <summary>
            Touches the specified element so that it is changed for the compiler and triggers a recompile.
            </summary>
        </member>
        <member name="T:VL.Model.CompileTimeValue">
            <summary>
            Values are stored as serialized JSON strings in our model and get deserialized using an external type annotation.
            This class helps to deal with the various cases which can go wrong during the deserialization of such a value.
            </summary>
        </member>
        <member name="P:VL.Model.CompileTimeValue.SerializedValue">
            <summary>
            The string or XElement.
            </summary>
        </member>
        <member name="T:VL.Model.ModelExtensions">
            <summary>
            General helpers for data hubs, extracted from ModelExtensions.
            for higher level stuff see the extension methods in Commands.cs
            </summary>
            <summary>
            General helpers for the model,
            for higher level stuff see the extension methods in Commands.cs
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsPinOnNodeOrRegion(VL.Model.Element)">
            <summary>
            Determines whether this is a small in/out pin on a node or region.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsPinOnProcessNode(VL.Model.Element)">
            <summary>
            Determines whether this is a small in/out pin on a process node or region fragment.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsControlPointInLink(VL.Model.DataHub)">
            <summary>
            Determines whether this control point is a middle control point in a link.
            So it has the same link as incoming and outgoing link.
            </summary>
            <param name="hub">The hub</param>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsSignatureHub(VL.Model.Element)">
            <summary>
            Determines whether this element is a border control point or a pin of a patch.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsPinOfPatch(VL.Model.Element)">
            <summary>
            Determines whether this element is a pin of a patch
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetConnectedOperationInputPin(VL.Model.Element)">
            <summary>
            If directly connected to an input pin of a surrounding operation defintion or member operation definition. Outputs this Pin (typically downstream connected to a proxy)
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.CanReplaceWithDelegate(VL.Model.DataHub,VL.Lang.Symbols.IConcreteTypeSymbol@)">
            <summary>
            Determines whether this data hub can be replaced with a delegate
            </summary>
            <param name="dataHub">The data hub.</param>
            <param name="delType">Type of the delete or null</param>
            <returns></returns>
        </member>
        <member name="M:VL.Model.ModelExtensions.NameVersionAndModelCategory(VL.Model.Node)">
            <summary>
            The model category contains "Experimental" (..). If this is not wanted use GetSymbol().GetInfoString()
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetFrom``1(``0,VL.Model.Compound)">
            <summary>
            Gets the element from the state of the given parent element. Calls GetNewElement internally.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetFrom``1(VL.Model.ElementId,VL.Model.Compound)">
            <summary>
            Gets the element with this ID from the state of the given parent element. Calls GetDescenent internally.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetCurrent``1(``0)">
            <summary>
            Gets the element from the CurrentSolution of the session.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsAssigned(VL.Model.Element)">
            <summary>
            Determines whether this element is assigned to a subpatch (not indy/master).
            </summary>
            <param name="element">The element.</param>
        </member>
        <member name="M:VL.Model.ModelExtensions.IsAssigned(VL.Model.Element,System.Collections.Generic.IEnumerable{VL.Model.Patch}@)">
            <summary>
            Determines whether this element is assigned to a subpatch (not indy/master).
            </summary>
            <param name="element">The element.</param>
            <param name="containingPatches">The containing patches.</param>
        </member>
        <member name="M:VL.Model.ModelExtensions.BatchUpdate``1(``0,System.Func{``0,``0})">
            <summary>
            Applies the given update function in an environment where no ancestor updates will be done.
            It's therefor only possible to use this function if the update function does not dependend
            on up-to-date parent information.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.UpdateDescendents``2(``0,System.Func{``1,System.Object},System.Boolean)">
            <summary>
            Updates all the descendants of the container with the given element type from top to bottom.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TElement">The type of descendants for which to apply the update function.</typeparam>
            <param name="container">The container to update.</param>
            <param name="update">The update function. Either return null to delete the descendant or one or many elements to replace it.</param>
            <param name="traverseIntoCanvases">Whether to traverse into canvases.</param>
            <returns>A new container if any descendent was indeed updated.</returns>
        </member>
        <member name="M:VL.Model.ModelExtensions.UpdateDescendentsBottomUp``2(``0,System.Func{``1,System.Object},System.Boolean)">
            <summary>
            Updates all the descendants of the container with the given element type from bottom to top.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TElement">The type of descendants for which to apply the update function.</typeparam>
            <param name="container">The container to update.</param>
            <param name="update">The update function. Either return null to delete the descendant or one or many elements to replace it.</param>
            <param name="traverseIntoCanvases">Whether to traverse into canvases.</param>
            <returns>A new container if any descendent was indeed updated.</returns>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetCommonAncestor(System.Collections.Generic.IEnumerable{VL.Model.Element})">
            <summary>
            The returned container contains all the given elements. It is the ancestor of all elements. 
            If you input a set of elements where one element is an ancestor of all others it sill won't return this element, but its parent.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetUndoContext(VL.Model.Canvas)">
            <summary>
            Gets the undo context. Either the canvas itself if it is a Group, or the parent definition if it is the canvas of type definition.
            </summary>
            <param name="canvas">The canvas.</param>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetTopElement(System.Collections.Generic.IEnumerable{VL.Model.Element})">
            <summary>
            Fair operation. Gives the top of the selected elements within the graph. The top element can be one of the input elements or an ancestor theirof.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.Reduce(System.Collections.Generic.IEnumerable{VL.Model.Element},System.Collections.Generic.IEqualityComparer{VL.Model.Element})">
            <summary>
            Returns a subset of the original sequence that only contains those elements that are no descendants of any other element of the original sequence.
            Returns a set of elements where none of the elements are in a parent-child relationship. The returned indendependant roots don't have to siblings.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetSelectionForDuplication(System.Collections.Generic.IEnumerable{VL.Model.Element},System.Collections.Generic.HashSet{VL.Model.Element}@)">
            <summary>
            Expands the selection to include referenced pins, slots and subpatches. The additional selected elements will
            also be returned in a seperate set so subsequent operations can act on that information.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.PackIntoContainer(System.Collections.Generic.IEnumerable{VL.Model.Element},System.Collections.Generic.HashSet{VL.Model.Element}@)">
            <summary>
            Returns a modified common anscestors of the given elements and all the links between them. 
            Will also add shallow compounds to the set of marked elements.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.AddDelegate(VL.Model.Patch,VL.Model.Point2,VL.Lang.Symbols.IConcreteTypeSymbol,VL.Model.Canvas)">
            <summary>
            Adds a delegate of the given type to the patch
            </summary>
            <param name="parentPatch">The patch.</param>
            <param name="location">The location.</param>
            <param name="funcType">Type of the new delegate</param>
            <param name="parentCanvas">The parent canvas.</param>
            <returns>The created delegate</returns>
        </member>
        <member name="M:VL.Model.ModelExtensions.HasMasterPatchWithCanvas(VL.Model.Node)">
            <summary>
            Determines whether the node has a master patch with exactly one canvas
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.MasterPatchCanvas(VL.Model.Node)">
            <summary>
            Gets the canvas of the master patch if the master patch has exactly one canvas
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetDefiningCanvas(VL.Model.Node,VL.Lang.Symbols.PreCompilation)">
            <summary>
            Tries to find the canvas that contains the implementation of this node, returns null if not found.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetOrAddCanvasForCategory(VL.Model.Canvas,VL.Lang.Symbols.Category,System.Collections.Generic.Dictionary{VL.Lang.Symbols.Category,VL.Model.Canvas})">
            <summary>
            Gets the first canvas for the given category in this root canvas or creates it if it doesn't exist yet.
            </summary>
        </member>
        <member name="M:VL.Model.ModelExtensions.GetDefiningNode(VL.Lang.Symbols.INodeDefinitionSymbol)">
            <summary>
            Tries to find the node element defining this definition. Will return the node defining the containing type for member operations.
            Note that the returned element might be from an older snapshot due to incremental compilation.
            </summary>
        </member>
        <member name="T:VL.Model.PinVisibility">
            <summary>
            Controls the visibility of pins. 
            </summary>
        </member>
        <member name="F:VL.Model.PinVisibility.Visible">
            <summary>
            The pin is always visible.
            </summary>
        </member>
        <member name="F:VL.Model.PinVisibility.Optional">
            <summary>
            The user can configure the node to show this pin on application side.
            </summary>
        </member>
        <member name="F:VL.Model.PinVisibility.Hidden">
            <summary>
            The user won't see the pin.
            </summary>
        </member>
        <member name="T:VL.Model.PinExpositionMode">
            <summary>
            Aka AutoConnect. Makes the pin show up in the parent(s).
            </summary>
        </member>
        <member name="F:VL.Model.PinExpositionMode.Local">
            <summary>
            Off
            </summary>
        </member>
        <member name="F:VL.Model.PinExpositionMode.InfectPatch">
            <summary>
            Makes the pin show up in the surrounding patch
            </summary>
        </member>
        <member name="F:VL.Model.PinExpositionMode.Expose">
            <summary>
            Infect all surrounding patches (the call stack)
            </summary>
        </member>
        <member name="M:VL.Model.NodeKindHelper.IsImmutableTypeDefinition(VL.Model.ElementKind)">
            <summary>
            True for records and enums.
            </summary>
        </member>
        <member name="M:VL.Model.IntegerExtensions.ToRoman(System.Int32)">
            <summary>
            Converts an integer into a roman numeral.
            </summary>
            <param name="number">
            The number being transformed.
            </param>
            <returns>
            A string representation of the number's corresponding roman numeral.
            </returns>
        </member>
        <member name="M:VL.Model.PackageExtensions.IsVlPackage(NuGet.IPackage)">
            <summary>
            Whether or not the package contains a main VL document and can therefor be considered a VL package.
            </summary>
        </member>
        <member name="M:VL.Model.PackageExtensions.GetMainDocumentFilePath(NuGet.IPackage)">
            <summary>
            Returns the VL document of the same name as the package.
            </summary>
        </member>
        <member name="T:VL.Model.Point2">
            <summary>
            To get rid of System.Drawing dependency (not cross-platform).
            </summary>
        </member>
        <member name="T:VL.Model.Rectangle2">
            <summary>
            To get rid of System.Drawing dependency (not cross-platform).
            </summary>
        </member>
        <member name="T:VL.Model.Size2">
            <summary>
            To get rid of System.Drawing dependency (not cross-platform).
            </summary>
        </member>
        <member name="P:VL.Model.IInfo.Summary">
            <summary>
            A short description.
            </summary>
        </member>
        <member name="P:VL.Model.IInfo.Remarks">
            <summary>
            Remarks are about details.
            </summary>
        </member>
        <member name="P:VL.Model.ITaggedInfo.Tags">
            <summary>
            For being bale to find the entity.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.remarks">
            <summary>
            Useful remarks to the entity.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.tags">
            <summary>
            Additional tags to describe the entity.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.authors">
            <summary>
            A comma separated list of authors who wrote this document.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.credits">
            <summary>
            Credits to third party code used in this document.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.licenseUrl">
            <summary>
            The URL to the license.
            </summary>
        </member>
        <member name="F:VL.Model.TaggedInfo55.projectUrl">
            <summary>
            The URL to the project (if any).
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.Authors">
            <summary>
            A comma separated list of authors who wrote this document.
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.Credits">
            <summary>
            Credits to third party code used in this document.
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.LicenseUrl">
            <summary>
            The URL to the license.
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.ProjectUrl">
            <summary>
            The URL to the project (if any).
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.Remarks">
            <summary>
            Useful remarks to the entity.
            </summary>
        </member>
        <member name="P:VL.Model.TaggedInfo55.Tags">
            <summary>
            Additional tags to describe the entity.
            </summary>
        </member>
        <member name="P:VL.Model.ICompileTimeValue.SerializedValue">
            <summary>
            The serialized string or XElement.
            </summary>
        </member>
        <member name="P:VL.Model.IElement.Identity">
            <summary>
            The unique id of the element. Note that the id is only unique in memory.
            </summary>
        </member>
        <member name="P:VL.Model.IElement.SerializedId">
            <summary>
            The unique persistent id of the element generated when the element was created the first time and persisted across serializations.
            </summary>
        </member>
        <member name="P:VL.Model.IElement.TracingId">
            <summary>
            The id used by runtime to fetch values and measrue method calls. Usually the same as the element id.
            </summary>
        </member>
        <member name="P:VL.Model.IElement.HotSwapId">
            <summary>
            The id used by hot swap to align the fields. Usually the same as the tracing id.
            </summary>
        </member>
        <member name="P:VL.Model.IPin.IsPinGroup">
            <summary>
            Wether or not this pin definition should be exposed on application side as a pin group.
            </summary>
        </member>
        <member name="P:VL.Model.IPin.PinGroupName">
            <summary>
            The pin group on application side this pin belongs to.
            </summary>
        </member>
        <member name="P:VL.Model.IPin.PinGroupDefaultCount">
            <summary>
            The number of pins to create for a pin group when first creating a node.
            </summary>
        </member>
        <member name="P:VL.Model.IPatch.SupportsPins">
            <summary>
            Whether or not the user is free to create pins in this patch.
            </summary>
        </member>
        <member name="M:VL.Model.ModelInterfaceExtensions.GetClrValue(VL.Model.ICompileTimeValue,VL.Lang.Symbols.ITargetCompilation,VL.Lang.Symbols.IScope)">
            <summary>
            The CLR value or null if the type can't be resolved.
            </summary>
        </member>
        <member name="M:VL.Model.ModelInterfaceExtensions.GetClrValue(VL.Lang.Symbols.ICompileTimeValueSymbol,VL.Lang.Symbols.ITargetCompilation)">
            <summary>
            The CLR value or null if the type can't be resolved.
            </summary>
        </member>
        <member name="M:VL.Model.Overlay.WithFillColor(System.Nullable{System.Drawing.Color})">
            <summary>
            You can reset that to default by setting null. The UI might still draw a color depending on the value of ColorIndex.
            </summary>
        </member>
        <member name="M:VL.Model.Overlay.WithColorIndex(System.Nullable{System.Int32})">
            <summary>
            You can reset that to default by setting null. The UI might still draw a color depending on the value of FillColor.
            </summary>
        </member>
        <member name="T:VL.Model.FullNameCategoryReference">
            <summary>
            refers to a category and its owners in namespace style.  e.g. "Math.Trigonometry"
            </summary>
            
        </member>
        <member name="M:VL.Model.ReferenceToSymbol.ToFixedTypeReference(VL.Lang.Symbols.ITypeSymbol)">
            <summary>
            A type reference which is hard wired to the given type. Use only for generated VL patches.
            </summary>
        </member>
        <member name="T:VL.Model.TypeReference">
            <summary>
            may resolve to a concrete type
            context may be a concrete type defintion or an operation definition
            </summary>
        </member>
        <member name="P:VL.Model.VLSession.RootProcessDefinitions">
            <summary>
            Returns all the ungeneric process definitions named "Application".
            </summary>
        </member>
        <member name="P:VL.Model.VLSession.Name">
            <summary>
            The name of session. Will be used to compute the user document root folder. Examples are "beta", "gamma" or "xenko".
            </summary>
        </member>
        <member name="P:VL.Model.VLSession.VersionString">
            <summary>
            The full version string. e.g. "2019.1.0" or "2019.1.0-0063-g2b0be431ff" for preview
            </summary>
        </member>
        <member name="P:VL.Model.VLSession.IsPreview">
            <summary>
            If set the user document root folder will be suffixed with "-preview".
            </summary>
        </member>
        <member name="P:VL.Model.VLSession.IsStandalone">
            <summary>
            Gets a value indicating whether this instance is vvvv gamma standalone.
            </summary>
        </member>
        <member name="M:VL.Model.VLSession.EnsureTracked(VL.Model.Canvas)">
            <summary>
            Tracks the specified canvas for undo/redo.
            </summary>
            <param name="canvas">The canvas to track.</param>
        </member>
        <member name="F:VL.Model.SolutionUpdateKind.UpdateUIAndHistory">
            <summary>
            To update UI and add change to history for undo, but does not trigger a recompile
            </summary>
        </member>
        <member name="M:VL.MutableModel.CompileTimeValue.#ctor(VL.Model.TypeReference,System.Object)">
            <summary>
            
            </summary>
            <param name="typeAnnotation"></param>
            <param name="serializedValue"></param>
        </member>
        <member name="P:VL.MutableModel.CompileTimeValue.SerializedValue">
            <summary>
            The string or XElement.
            </summary>
        </member>
        <member name="T:Microsoft.Threading.AsyncPump">
            <summary>Provides a pump that supports running asynchronous methods on the current thread.</summary>
        </member>
        <member name="M:Microsoft.Threading.AsyncPump.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>Runs the specified asynchronous function.</summary>
            <param name="func">The asynchronous function to execute.</param>
        </member>
        <member name="T:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext">
            <summary>Provides a SynchronizationContext that's single-threaded.</summary>
        </member>
        <member name="F:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.m_queue">
            <summary>The queue of work items.</summary>
        </member>
        <member name="F:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.m_thread">
            <summary>The processing thread.</summary>
        </member>
        <member name="M:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Dispatches an asynchronous message to the synchronization context.</summary>
            <param name="d">The System.Threading.SendOrPostCallback delegate to call.</param>
            <param name="state">The object passed to the delegate.</param>
        </member>
        <member name="M:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Not supported.</summary>
        </member>
        <member name="M:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.RunOnCurrentThread">
            <summary>Runs an loop to process all queued work items.</summary>
        </member>
        <member name="M:Microsoft.Threading.AsyncPump.SingleThreadSynchronizationContext.Complete">
            <summary>Notifies the context that no more work will arrive.</summary>
        </member>
        <member name="T:Ascii85">
            <summary>
            C# implementation of ASCII85 encoding. 
            Based on C code from http://www.stillhq.com/cgi-bin/cvsweb/ascii85/
            </summary>
            <remarks>
            Jeff Atwood
            http://www.codinghorror.com/blog/archives/000410.html
            </remarks>
        </member>
        <member name="F:Ascii85.PrefixMark">
            <summary>
            Prefix mark that identifies an encoded ASCII85 string, traditionally '&lt;~'
            </summary>
        </member>
        <member name="F:Ascii85.SuffixMark">
            <summary>
            Suffix mark that identifies an encoded ASCII85 string, traditionally '~&gt;'
            </summary>
        </member>
        <member name="F:Ascii85.LineLength">
            <summary>
            Maximum line length for encoded ASCII85 string; 
            set to zero for one unbroken line.
            </summary>
        </member>
        <member name="F:Ascii85.EnforceMarks">
            <summary>
            Add the Prefix and Suffix marks when encoding, and enforce their presence for decoding
            </summary>
        </member>
        <member name="M:Ascii85.Decode(System.String)">
            <summary>
            Decodes an ASCII85 encoded string into the original binary data
            </summary>
            <param name="s">ASCII85 encoded string</param>
            <returns>byte array of decoded binary data</returns>
        </member>
        <member name="M:Ascii85.Encode(System.Byte[])">
            <summary>
            Encodes binary data into a plaintext ASCII85 format string
            </summary>
            <param name="ba">binary data to encode</param>
            <returns>ASCII85 encoded string</returns>
        </member>
    </members>
</doc>
