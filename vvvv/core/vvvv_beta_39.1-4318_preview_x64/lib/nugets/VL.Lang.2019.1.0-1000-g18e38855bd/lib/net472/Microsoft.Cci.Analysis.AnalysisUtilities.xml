<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Cci.Analysis.AnalysisUtilities</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Cci.Analysis.Interval">
            <summary>
            An inclusive numeric interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.#ctor">
            <summary>
            An inclusive numeric interval from minus infinity to plus infinity.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.#ctor(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            An inclusive numeric interval. If the bounds are floating point numbers, they are finite. The bounds must contain values of the same type.
            </summary>
            <param name="lowerBound">The inclusive lower bound of the interval. If this value is null or Dummy.Constant, it means the lower bound is unknown.</param>
            <param name="upperBound">The inclusive upper bound of the interval. If this value is null or Dummy.Constant, it means the lower bound is unknown.</param>
            <param name="excludesMinusOne">If true, an expression that results in this interval at compile time can never result in -1 at runtime. If false,
            the value of this.ExcludesMinusOne will be determined by the given lower and upper bounds.</param>
            <param name="excludesZero">If true, an expression that results in this interval at compile time can never result in zero at runtime. If false,
            the value of this.ExcludesZero will be determined by the given lower and upper bounds.</param>
            <param name="includesDivisionByZero">If true, an expression that results in this interval at compile time may result in division by zero at runtime.</param>
            <param name="includesOverflow">If true, an expression that results in this integer interval at compile time may result in an overflow value at runtime.</param>
            <param name="includesUnderflow">If true, an expression that results in this integer interval at compile time may result in an underflow value at runtime.</param>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.ExcludesMinusOne">
            <summary>
            True if -1 is not a member of this interval.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.ExcludesZero">
            <summary>
            True if 0 is not a member of this interval.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.IncludesDivisionByZero">
            <summary>
            If true, an expression that results in this interval at compile time may result in division by zero at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.IncludesOverflow">
            <summary>
            If true, an expression that results in this integer interval at compile time may result in an overflow value at runtime.
            If expression does not check for overflow then then lower and upper bounds of the 
            interval will be the minimum and maximum values of the appropriate integer type, respectively.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.IncludesUnderflow">
            <summary>
            If true, an expression that results in this integer interval at compile time may result in an underflow value at runtime.
            If expression does not check for overflow then then lower and upper bounds of the 
            interval will be the minimum and maximum values of the appropriate integer type, respectively.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.IsFinite">
            <summary>
            True if both the lower and upper bounds of the interval are known and finite and if the interval does not include division by zero or overflow values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.IsUnusable">
            <summary>
            True if the expression that results in this interval is known at compile time to always result in a runtime exception.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.LowerBound">
            <summary>
            The inclusive lower bound of the interval.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Interval.UpperBound">
            <summary>
            The inclusive upper bound of the interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Clone">
            <summary>
            Returns a shallow copy of this Interval.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.ExcludesMinimumValue(Microsoft.Cci.ITypeReference)">
            <summary>
            True if the lower bound of this integer interval is greater than the minimum value of the given type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.GetAsSingleton">
            <summary>
            If the interval includes a single number return that number.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.GetIntervalFor``1(Microsoft.Cci.Analysis.Join,Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Returns the smallest interval that contains the intervals obtained for each of the variables whose values are joined
            together by the given join. If no such interval exists, the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.GetIntervalFor``1(Microsoft.Cci.INamedEntity,System.Object,Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Returns the smallest interval that contains all possible runtime values the given variable may take on in while control is inside the given block
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Join(Microsoft.Cci.Analysis.Interval)">
            <summary>
            Returns an interval with includes this interval as well as the other interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(``0,Microsoft.Cci.Analysis.Interval,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval which is associated with the given expression, by applying the constraints that are known to hold inside the referring block.
            If the joinBlock is not null, the interval is first narrowed with any constraints that apply to the transition from definingBlock to joinBlock.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(``0,Microsoft.Cci.Analysis.Interval,System.Collections.Generic.List{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval, which is associated with the given expression, by applying the given list of constraints that are known to hold inside the referring block
            whenever it referes to the given expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(``0,Microsoft.Cci.Analysis.Interval,``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval, which is associated with the given expression, by applying the given constraint that is known to hold inside the referring block
            whenever it refers to the given expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.Interval,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval, which is associated with the given local or parameter, by applying the constraints that are known to hold inside the referring block.
            If the joinBlock is not null, the interval is first narrowed with any constraints that apply to the transition from definingBlock to joinBlock.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.Interval,System.Collections.Generic.List{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval, which is associated with the given local or parameter, by applying the given list of constraints that are known to hold inside the referring block
            whenever it referes to the given local or parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow``1(Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.Interval,``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Narrows the given interval, which is associated with the given local or parameter, by applying the given constraint that is known to hold inside the referring block
            whenever it referes to the given local or parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow(Microsoft.Cci.Analysis.Interval,Microsoft.Cci.OperationCode,Microsoft.Cci.IMetadataConstant)">
            <summary>
            Narrows the given interval by applying a constraint expressed by the given operation code and compile time constant.
            Think of this as enforcing the constraint that x op cv must be true for any value x in the given interval.
            For example, if the operation code is Bge and the constant is 10 then the lower bound of the interval is set to 10, if
            this will result in a narrower interval. The change is peformed by mutating the given interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow(Microsoft.Cci.Analysis.Interval,Microsoft.Cci.OperationCode,Microsoft.Cci.Analysis.Interval)">
            <summary>
            Narrows interval1 by applying a constraint expressed by the given operation code and another interval, interval2.
            Think of this as enforcing the constraint that x op y must be true for any value x in interval1 and any value y in interval2.
            For example, if the operation code is Bge and the other interval is 10..20 then the lower bound of the interval is set to 20, if
            this will result in a narrower interval. The change is peformed by mutating the given interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.Narrow2(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.OperationCode,Microsoft.Cci.Analysis.Interval)">
            <summary>
            Narrows the given interval by applying a constraint expressed by the given operation code and compile time constant.
            Think of this as enforcing the constraint that cv op x must be true for any value x in the given interval.
            For example, if the operation code is Bge and the constant is 10 then the upper bound of the interval is set to 10, if
            this will result in a narrower interval. The change is peformed by mutating the given interval.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.TryToGetAsInterval``1(``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Computes a numeric interval to bound the value that the given expression results in. 
            If the expression cannot be bounded by a numeric interval, the result is null.
            </summary>
            <param name="expression">An instruction that results in a value.</param>
            <param name="referringBlock">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible.</param>
            <param name="joinBlock">If the expression is a component of a join ("phi" node), then joinBlock is the block in which the join is defined.</param>
            <param name="definingBlock">If the expression is a component of a join ("phi" node), then definingBlock is the block from which the component expression flowed to joinBlock.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
            <returns>
            An interval that bounds the values of the expression to a value between upper and lower bounds.
            If the expression cannot be bounded, for instance because it does not result int a numeric type, the result is null.
            </returns>
            <remarks>
            This method does not add its result to the cache, nor does it check the cache for existing result.
            The reason for this is that while the abstract interpretation proceeds, intervals can become more refined.
            Once abstract interpretation is done, clients will obtain intervals via mappings, not this class.
            If there is a cache miss, mappings will call this class and do the caching.
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.TryToGetAsInterval0``1(``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Computes a numeric interval to bound the value that the given nullary expression results in. 
            If the expression cannot be bounded by a numeric interval, the result is null.
            </summary>
            <param name="expression">An instruction that results in a value.</param>
            <param name="referringBlock">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible.</param>
            <param name="joinBlock">If the expression is a component of a join ("phi" node), then joinBlock is the block in which the join is defined.</param>
            <param name="definingBlock">If the expression is a component of a join ("phi" node), then definingBlock is the block from which the component expression flowed to joinBlock.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
            <returns>
            An interval that bounds the values of the expression to a value between upper and lower bounds.
            If the expression cannot be bounded, for instance because it does not result int a numeric type, the result is null.
            </returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.TryToGetAsInterval1``1(``0,``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Computes a numeric interval to bound the value that the given unary expression results in. 
            If the expression cannot be bounded by a numeric interval, the result is null.
            </summary>
            <param name="expression">An instruction that results in a value.</param>
            <param name="operand"></param>
            <param name="referringBlock">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible.</param>
            <param name="joinBlock">If the expression is a component of a join ("phi" node), then joinBlock is the block in which the join is defined.</param>
            <param name="definingBlock">If the expression is a component of a join ("phi" node), then definingBlock is the block from which the component expression flowed to joinBlock.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
            <returns>
            An interval that bounds the values of the expression to a value between upper and lower bounds.
            If the expression cannot be bounded, for instance because it does not result int a numeric type, the result is null.
            </returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.TryToGetAsInterval2``1(``0,``0,``0,Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0},Microsoft.Cci.Analysis.ValueMappings{``0})">
            <summary>
            Computes a numeric interval to bound the value that the given binary expression results in. 
            If the expression cannot be bounded by a numeric interval, the result is null.
            </summary>
            <param name="expression">An instruction that results in a value.</param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="referringBlock">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible.</param>
            <param name="joinBlock">If the expression is a component of a join ("phi" node), then joinBlock is the block in which the join is defined.</param>
            <param name="definingBlock">If the expression is a component of a join ("phi" node), then definingBlock is the block from which the component expression flowed to joinBlock.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
            <returns>
            An interval that bounds the values of the expression to a value between upper and lower bounds.
            If the expression cannot be bounded, for instance because it does not result int a numeric type, the result is null.
            </returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Interval.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Microsoft.Cci.Analysis.AbstractInterpreter`2">
            <summary>
            Provides a static method that interprets a control and data flow graph in order to compute the concrete (if possible) or abstract values of the local variables defined
            in the graph. This analysis requires the graph to be in SSA format.
            </summary>
            <typeparam name="BasicBlock">A type that is a subtype of Microsoft.Cci.Analysis.SSABasicBlock.</typeparam>
            <typeparam name="Instruction">A type that is a subtype of Microsoft.Cci.Analysis.Instruction and that has a default constructor.</typeparam>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.InterpretUsingAbstractValues(Microsoft.Cci.Analysis.ControlAndDataFlowGraph{`0,`1},Microsoft.Cci.Analysis.ControlGraphQueries{`0,`1},Microsoft.Cci.Analysis.ValueMappings{`1})">
            <summary>
            Interprets the instructions in the given control and data flow graph, computing an abstract value for each instruction that produces a value.
            In some cases, it is also possible to compute concrete values. When these values are stored into variables, this is recorded in the given
            environment. The input graph is required to be in SSA format, so the recorded values will be accurate at all points where the variables
            are accessed in the graph.
            </summary>
            <param name="cdfg">A control and data flow graph in SSA form, to interpret in order to compute concrete and abstract values for variables in the graph.</param>
            <param name="cfgQueries">Presents information derived from a simple control flow graph. For example, traversal orders, predecessors, dominators and dominance frontiers.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.#ctor(Microsoft.Cci.Analysis.ControlAndDataFlowGraph{`0,`1},Microsoft.Cci.Analysis.ControlGraphQueries{`0,`1},Microsoft.Cci.Analysis.ValueMappings{`1})">
            <summary>
            Creates an object that interprets a control and data flow graph in order to compute the concrete (if possible) or abstract values of the local variables defined
            in the graph. This analysis requires the graph to be in SSA format.
            </summary>
            <param name="cdfg">A control and data flow graph in SSA form, to interpret in order to compute concrete and abstract values for variables in the graph.</param>
            <param name="cfgQueries">Presents information derived from a simple control flow graph. For example, traversal orders, predecessors, dominators and dominance frontiers.</param>
            <param name="mappings">Provides several maps from expressions to concrete and abstract values.</param>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.cdfg">
            <summary>
            A control and data flow graph in SSA form, to interpret in order to compute concrete and abstract values for variables in the graph.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.cfgQueries">
            <summary>
            Presents information derived from a simple control flow graph. For example, traversal orders, predecessors, dominators and dominance frontiers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.mappings">
            <summary>
            Provides several maps from expressions to concrete and abstract values.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.blocksToInterpret">
            <summary>
            Keeps track of all of the blocks that should be considered again by the interpreter. A block can show up in here more than once.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.blocksInterpretedAtLeastOnce">
            <summary>
            A set of all basic blocks that have been interpreted at least once by the abstract interpreter.
            A block can be interpreted more than once when loops are encountered and a fix point is being calculated.
            The main reason to have this set is to allow the fix point to be detected in such a way that each
            block is interpreted at least once.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.constraints">
            <summary>
            Zero or more expressions that are currently known to be true.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.currentBlock">
            <summary>
            The basic block that is currently being interpreted.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.expressionCanonicalizer">
            <summary>
            A special kind of hash table that maps expressions to equivalent expressions that have been canonicalized.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.lastStatementWasUnconditionalTransfer">
            <summary>
            True if the last interpreted instruction was an unconditional branch. (This includes condition branches whose conditions are compile time constants.)
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AbstractInterpreter`2.liveSuccessorBlocks">
            <summary>
            The set of blocks that are not known at this point to be unreachable from the block currently being interpreted.
            Add the target block to this set whenever interpreting a branch instruction that might be taken. Also add the fall through block
            if the last interpreted instruction was not an unconditional transfer.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.Interpret">
            <summary>
            Starting with each root, run through all reachable blocks and abstractly interpret their instructions.
            At the end of this, every instruction that computes a value will be associated with an expression that
            represents that value and optionally with a compile time constant if the value is known at compile time.
            Note that expressions are just instructions plus their data flow graphs (for which an instruction happens to be a convenient object model)
            but the "expression object" associated with a particular instruction is not necessarily the same object as the instruction,
            because the instruction, or a predecessor instruction in its data flow graph, may be equivalent to an earlier instruction. 
            In other words common subexpression elimination is performed. This reason for this is to make it easier to reason about the relationship between
            different expressions.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.Interpret(`0)">
            <summary>
            Abstractly interprets the instructions in the given block, if appropriate.
            By appropriate we mean that either the block has not yet been interpreted,
            or that that something has changed in the environment since we last interpreted
            the block. In the latter case, we interpret once again. As it happens, no precision
            is gained since the expressions that are produced by this interpreter retain full precision
            at all times. What we do gain from the additional iterations is further normalization of expressions
            that can lead to better subexpression identification and more constant folding.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.Interpret(`1,`0)">
            <summary>
            Interprets the given instruction using abstract values and associates an abstract value with the instruction (if it computes a value).
            Also updates this.liveSuccessorBlocks if instruction is a branch that might be taken. Sets this.lastStatementWasUnconditionalTransfer to
            true if instruction is an unconditional branch (which can be a conditional branch whose condition is a compile time constant).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.InterpretNullary(`1)">
            <summary>
            Interprets an instruction with no operands, using abstract values from the SSA environment if appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.InterpretUnary(`1,`1,`0)">
            <summary>
            Interprets an instruction with a single operand (which was computed by a previous instruction), using values from the SSA environment.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.InterpretBinary(`1,`1,`1,Microsoft.Cci.Analysis.AiBasicBlock{`1})">
            <summary>
            Interprets an instruction with two operands (which were computed by previous instructions), using values from the SSA environment.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.InterpretNary(`1,`1,`1[])">
            <summary>
            Interprets an instruction with three or more operands.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.TryToGetCompileTimeConstantValueFor(`1)">
            <summary>
            If the value that the given expression evaluates to at runtime is known at compile time, return that value as an IMetadataConstant instance.
            If it is known at compile time that the expression will fail at runtime, or if its runtime value is not known at compile time, the result of this method is null.
            </summary>
            <param name="expression">An instruction that results in a value at runtime.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.UnionOfJoinedValues(Microsoft.Cci.Analysis.Join,`0)">
            <summary>
            Returns a canonicalized expression with a Dummy operation value and a set of operands that
            represent all of the values that may be assigned to this variable by preceding instructions.
            </summary>
            <remarks>
            When canonicalizing expressions that contain unions as subexpressions, 
            distribute over unions so that the union is always the outer expression of the canonical expression.
            For example i + union(j, k) becomes union(i+j, i+k) 
            and union (i, j) + union (j, k) becomes union(i+j, i+k, j+j, j+k).
            </remarks>
        </member>
        <member name="M:Microsoft.Cci.Analysis.AbstractInterpreter`2.GetCanonicalizedLoadInstruction(System.Object)">
            <summary>
            Given a local or a parameter, return a canonicalized expression that will load the value of the local or parameter at runtime.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.AiBasicBlock`1">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AiBasicBlock`1.FallThroughBlock">
            <summary>
            The block, if any, that follows this block in the sequence of instructions. It may not be reachable from the block.
            If this block is the last block, the value will be null.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.AiBasicBlock`1.Predecessors">
            <summary>
            A non null (but delay initialized) list of the blocks that transfer control to this block.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.AiBasicBlock`1.ConstantForExpression">
            <summary>
            A table keeping track of Interval values that have been computed for instructions in the context
            of this block. (An expression can result in a different interval or constnat in this block because this
            block might have entry constraints that narrow the interval.)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.AiBasicBlock`1.ConstraintsAtEntry">
            <summary>
            A list of lists where every element list is a list of constraints that were established by one of the predecessors to this block.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.AiBasicBlock`1.ConstraintsAtExit">
            <summary>
            A list of lists where every element list is a list of constraints that hold when transfer controls to a successor block.
            The indices of the outer list match the indices of the Successor list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.AiBasicBlock`1.IntervalForExpression">
            <summary>
            A table keeping track of Interval values that have been computed for instructions in the context
            of this block. (An expression can result in a different interval or constnat in this block because this
            block might have entry constraints that narrow the interval.)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.AiBasicBlock`1.SatSolverContext">
            <summary>
            A context in which to keep the constraints at entry in SAT solver format, so that they can be used
            together with particular expressions to determine satisfiablity.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.Evaluator">
            <summary>
            Provides methods that carry out IL operations with compile time constant operand values at compile time, if possible.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.ConvertToUnsigned(Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.DecreaseBySmallestInterval(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Returns a compile time constant that is the same as the given constant, except that numeric values
            are decremented by the smallest interval appropriate to its type. If the decrement causes underflow to 
            happen, the result is just the given constant.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate(Microsoft.Cci.IOperation,Microsoft.Cci.IMetadataConstant)">
            <summary>
            Evaluates the given unary operation for the given compile time constant.
            If the operation will fail if carried out at runtime, the result is Dummy.Constant.
            If the result of the operation cannot be known until runtime, for example because the size of IntPtr is only known at runtime, then the result is null.
            </summary>
            <param name="operation"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate(Microsoft.Cci.IOperation,Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operation"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate``1(Microsoft.Cci.IOperation,Microsoft.Cci.IMetadataConstant,``0,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="operation"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="mappings"></param>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate``1(Microsoft.Cci.IOperation,``0,Microsoft.Cci.IMetadataConstant,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="operation"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="mappings"></param>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate``1(Microsoft.Cci.IOperation,``0,``0,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="operation"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="mappings"></param>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Evaluate``1(Microsoft.Cci.IOperation,``0,``0[],Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.AiBasicBlock{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="operation"></param>
            <param name="operand1"></param>
            <param name="operands2toN"></param>
            <param name="mappings"></param>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetAsCompileTimeConstantValue(Microsoft.Cci.Analysis.Instruction)">
            <summary>
            Returns an IMetadataConstant instance that corresponds to the value that the given instruction will evaluate to at runtime.
            </summary>
            <param name="instruction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetMaxValue(Microsoft.Cci.ITypeReference)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetMinValue(Microsoft.Cci.ITypeReference)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetMinusOne(Microsoft.Cci.ITypeReference)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetOne(Microsoft.Cci.ITypeReference)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.GetZero(Microsoft.Cci.ITypeReference)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IncreaseBySmallestInterval(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Returns a compile time constant that is the same as the given constant, except that numeric values
            are incremented by the smallest interval appropriate to its type. If the increment causes overflow to 
            happen, the result is the given constant.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNumericallyEqual(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNumericallyGreaterThan(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNumericallyGreaterThanOrEqualTo(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNumericallyLessThan(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNumericallyLessThanOrEqualTo(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNegative(Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsNonNegative(Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsPositive(Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.IsSmallerThanMinusOne(Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Max(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Evaluator.Min(Microsoft.Cci.IMetadataConstant,Microsoft.Cci.IMetadataConstant)">
            <summary>
            
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ExpressionCanonicalizer`1.GetAsCanonicalizedLoadConstant(Microsoft.Cci.IMetadataConstant,`0)">
            <summary>
            Returns the canonical form of an expression that results in the given constant at runtime. 
            </summary>
            <param name="compileTimeConstant">The compile time constant that should be equal to the value the resulting expression will evaluate to at runtime.</param>
            <param name="originalInstruction">An instruction that will result in the given constant at runtime. The result of this method is a canonical form of this instruction.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ExpressionCanonicalizer`1.GetAsLoadConstant(System.IConvertible,`0)">
            <summary>
            Returns the canonical form of an expression that results in the given constant at runtime. 
            </summary>
            <param name="convertible">The value that the resulting expression must evaluate to at runtime.</param>
            <param name="originalInstruction">An instruction that will result in the given constant at runtime. The result of this method is a canonical form of this instruction.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ExpressionCanonicalizer`1.GetCanonicalExpression(`0)">
            <summary>
            If an expression equivalent to the given expression can be found in the cache, the result is that expression.
            Otherwise the result is the given expression and it is added to the cache as well.
            </summary>
            <param name="expression">An instruction that computes a value.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ExpressionCanonicalizer`1.GetCanonicalExpression(`0,`0)">
            <summary>
            If the cache contains an expression with an Operation structurally equivalent to unaryInstruction.Operation and Operand1 structurally equivalent to
            operand1, then return that expression. Otherwise construct such an expression, add it to the cache and return it.
            </summary>
            <param name="unaryInstruction">An instruction with a single operand.</param>
            <param name="operand1">The already canonicalized version of unaryInstruction.Operand1, if available, otherwise unaryInstruction.Operand1.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ExpressionCanonicalizer`1.GetCanonicalExpression(`0,`0,`0)">
            <summary>
            If the cache contains an expression with an Operation structurally equivalent to binaryInstruction.Operation, Operand1 structurally equivalent to
            operand1 and Operand2 structurally equivalent to the operand2, then return that expression. 
            Otherwise construct such an expression, simplify it and then add it to the cache and return it.
            </summary>
            <param name="binaryInstruction">An instruction with a two operands.</param>
            <param name="operand1">The already canonicalized version of binaryInstruction.Operand1, if available, otherwise binaryInstruction.Operand1.</param>
            <param name="operand2">The already canonicalized version of binaryInstruction.Operand2, if available, otherwise binaryInstruction.Operand2.</param>
        </member>
        <member name="T:Microsoft.Cci.Analysis.Purger">
            <summary>
            Rewrites Boolean expressions to exclude references to variables that have been updated.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Purger.Purge``1(``0,Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            Rewrites Boolean expressions to exclude references to variables that have been updated.
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="variable"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Purger.PurgeBinary``1(``0,Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            Uses Arithmetic and Boolean laws to simplify expressions.
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="variable"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Purger.PurgeUnary``1(``0,Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="variable"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.Analysis.ISatSolver">
            <summary>
            Implemented by an object that implements a Boolean Satisfibility Solver.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.ISatSolver.Dummy">
            <summary>
            An expression for which ISatSolverContext.Check always returns null.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.ISatSolver.False">
            <summary>
            An expression for which ISatSolverContext.Check always returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolver.GetNewContext">
            <summary>
            Provides a context that can hold a number of boolean expressions. 
            The solver is used to see if there exists an assignment of values to variables that will make all of the Boolean expressions true.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolver.MakeExpression(Microsoft.Cci.IOperation,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns an ISatExpressionWrapper instance that corresponds to the given operation. The operation takes no arguments, so it is expected
            to be a constant value or a variable reference. May return null if operation cannot be mapped to an expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolver.MakeExpression(Microsoft.Cci.IOperation,Microsoft.Cci.ITypeReference,Microsoft.Cci.Analysis.ISatExpressionWrapper)">
            <summary>
            Returns an ISatExpressionWrapper instance that corresponds to the given operation. The operation takes a single argument, so it is expected
            to involve a unary operator, such as - or ! or ~. May return null if operation cannot be mapped to an expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolver.MakeExpression(Microsoft.Cci.IOperation,Microsoft.Cci.ITypeReference,Microsoft.Cci.Analysis.ISatExpressionWrapper,Microsoft.Cci.Analysis.ISatExpressionWrapper)">
            <summary>
            Returns an ISatExpressionWrapper instance that corresponds to the given operation. The operation takes two arguments, so it is expected
            to involve a binary operator, such as * or / or ^. May return null if operation cannot be mapped to an expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolver.MakeImplication(Microsoft.Cci.Analysis.ISatExpressionWrapper,Microsoft.Cci.Analysis.ISatExpressionWrapper)">
            <summary>
            Returns an ISatExpressionWrapper instance that corresponds to operand1 => operand2.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.ISatSolver.True">
            <summary>
            An expression for which ISatSolverContext.Check always returns true.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.ISatSolverContext">
            <summary>
            A context that can hold a number of boolean expressions. 
            The solver is used to see if there exists an assignment of values to variables that will make all of the Boolean expressions true.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolverContext.Add(Microsoft.Cci.Analysis.ISatExpressionWrapper)">
            <summary>
            Adds a boolean expression to the context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolverContext.AddInverse(Microsoft.Cci.Analysis.ISatExpressionWrapper)">
            <summary>
            Adds the inverse of the given boolean expression to the context.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolverContext.Check">
            <summary>
            Checks if there exists an assigment of values to variables that will make all of the Boolean expressions in the context true.
            Since this problem is not decidable, the solver may not be able to return an answer, in which case the return result is null
            rather than false or true.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolverContext.MakeCheckPoint">
            <summary>
            Creates a check point from the expressions currently in the context. Any expressions added to the context after this call will be
            discarded when a corresponding call is made to RestoreCheckPoint.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.ISatSolverContext.NumberOfCheckPoints">
            <summary>
            The number of check points that have been created.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatSolverContext.RestoreCheckPoint">
            <summary>
            Discards any expressions added to the context since the last call to MakeCheckPoint. At least one check point must exist.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.ISatExpressionWrapper">
            <summary>
            A wrapper for an expression encoded in a format understood by the SAT solver.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.ISatExpressionWrapper.Type">
            <summary>
            The type of value this expression results in.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ISatExpressionWrapper.Unwrap``1">
            <summary>
            Unwraps the wrapped expression, returning a value of the type expected by the SAT solver.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.Simplifier">
            <summary>
            Uses Arithmetic and Boolean laws to simplify expressions.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Simplifier.Simplify``1(``0,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            Uses Arithmetic and Boolean laws to simplify expressions.
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="mappings"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Simplifier.SimplifyBinary``1(``0,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            Uses Arithmetic and Boolean laws to simplify expressions.
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="mappings"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Simplifier.HoistPhiNodes``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Simplifier.LongVersionOf(Microsoft.Cci.OperationCode)">
            <summary>
            If the given operation code is a short branch, return the corresponding long branch. Otherwise return the given operation code.
            </summary>
            <param name="operationCode">An operation code.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Simplifier.SimplifyUnary``1(``0,Microsoft.Cci.Analysis.ValueMappings{``0},Microsoft.Cci.Analysis.ExpressionCanonicalizer{``0})">
            <summary>
            
            </summary>
            <typeparam name="Instruction"></typeparam>
            <param name="instruction"></param>
            <param name="mappings"></param>
            <param name="canonicalizer"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.Analysis.SingleAssigner`2">
            <summary>
            Provides a static method that modifies a suitable control and data flow graph into a form where every local is assigned to in a single location.
            That is, the graph is put into Static Single Assignment (SSA) form. (The "Static" is an attempt to make it clear that a local can be assigned
            to many times dynamically (during execution) even though there is a single assignment instruction for it in the graph.)
            </summary>
            <typeparam name="BasicBlock">A type that is a subtype of Microsoft.Cci.Analysis.SSABasicBlock.</typeparam>
            <typeparam name="Instruction">A type that is a subtype of Microsoft.Cci.Analysis.Instruction and that has a default constructor.</typeparam>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.#ctor(Microsoft.Cci.INameTable,Microsoft.Cci.Analysis.ControlAndDataFlowGraph{`0,`1},Microsoft.Cci.Analysis.ControlGraphQueries{`0,`1},Microsoft.Cci.ISourceLocationProvider)">
            <summary>
            Initializes an instance of SingleAssigner.
            </summary>
            <param name="cdfg">
            A set of basic blocks, each of which has a list of successor blocks and some other information.
            Each block consists of a list of instructions, each of which can point to previous instructions that compute the operands it consumes.
            </param>
            <param name="nameTable">
            An extensible collection of IName instances that represent names that are commonly used during compilation.
            </param>
            <param name="cfgQueries"></param>
            <param name="sourceLocationProvider">An object that can map some kinds of ILocation objects to IPrimarySourceLocation objects. May be null.</param>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.nameTable">
            <summary>
            An extensible collection of IName instances that represent names that are commonly used during compilation.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.sourceLocationProvider">
            <summary>
            An object that can map some kinds of ILocation objects to IPrimarySourceLocation objects. May be null.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.localCounter">
            <summary>
            Used to make up unique names for the new locals introduced to make all assignments unique.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.cdfg">
            <summary>
            A set of basic blocks, each of which has a list of successor blocks and some other information.
            Each block consists of a list of instructions, each of which can point to previous instructions that compute the operands it consumes.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.cfgQueries">
            <summary>
            Presents information derived from a simple control flow graph. For example, traversal orders, predecessors, dominators and dominance frontiers.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.allReads">
            <summary>
            A list of all of the reads (join points or phi nodes) in this.cdfg. Used to avoid allocating new List objects for every block.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.blocksAlreadyVisited">
            <summary>
            Keeps track of all of the blocks that have already been visited. Used to break cycles during visitation.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SingleAssigner`2.ssaVariableFor">
            <summary>
            A map from the local (or parameter) used in the original IL to the new local written by the most recent assignment to the original local.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.GetInSingleAssignmentForm(Microsoft.Cci.INameTable,Microsoft.Cci.Analysis.ControlAndDataFlowGraph{`0,`1},Microsoft.Cci.Analysis.ControlGraphQueries{`0,`1},Microsoft.Cci.ISourceLocationProvider)">
            <summary>
            Rewrites the blocks in the given cdfg so that every assignment to a local or parameter is to a new local (and thus each local is just
            assigned to in exactly one place in the graph). The new names introduced by the writes are connected to the reads in successor blocks
            by means of join points (a.k.a. Phi nodes) that are found in the Reads property of an SSABasicBlock.
            </summary>
            <param name="cdfg">
            A set of basic blocks, each of which has a list of successor blocks and some other information.
            Each block consists of a list of instructions, each of which can point to previous instructions that compute the operands it consumes.
            </param>
            <param name="cfgQueries">
            Presents information derived from a simple control flow graph. For example, traversal orders, predecessors, dominators and dominance frontiers.
            </param>
            <param name="nameTable">
            An extensible collection of IName instances that represent names that are commonly used during compilation.
            </param>
            <param name="sourceLocationProvider"></param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.GetInSingleAssignmentForm">
            <summary>
            Rewrites the blocks in the given cdfg so that every assignment to a local or parameter is to a new local (and thus each local is just
            assigned to in exactly one place in the graph). The new names introduced by the writes are connected to the reads in successor blocks
            by means of join points (a.k.a. Phi nodes) that are found in the Reads property of an SSABasicBlock.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.CreateSSAVariablesAndJoinInformation(`0)">
            <summary>
            Runs through the instructions of the given block and updates any instruction that references a local or parameter
            to instead reference a SSA local or parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.ReplaceWithNewSSAValue(`1)">
            <summary>
            Makes up a new LocalDefinition or ParameterDefinition corresponding to the one in instruction.Operation.Value and 
            then updates instruction.Operation.Value with the new definition. The new definition will be an instance of
            SSALocalDefinition or SSAParameterDefinition, both of which retain a reference to the original definition
            so that the original IL can be recovered from the control flow graph even after it has been put into SSA form.
            </summary>
            <param name="instruction">The instruction to update.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.GetNewLocal(System.Object)">
            <summary>
            Returns a new SSALocalDefinition if the argument is a local or a new SSAParameterDefinition if the argument is a parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.GetLocalName(Microsoft.Cci.ILocalDefinition)">
            <summary>
            Looks up a source provided name for the local using this.sourceLocationProvider, if there is one.
            </summary>
            <param name="local"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SingleAssigner`2.GetNewName(System.String)">
            <summary>
            Makes up a new name that is derived from the given name, but distinct from all other local names in this graph.
            </summary>
            <remarks>Since all local names are going to get rewritten like this, they should remain unique if they started out that way.</remarks>
        </member>
        <member name="T:Microsoft.Cci.Analysis.SSABasicBlock`1">
            <summary>
            A basic block in a control flow graph, enhanced with information to help create and represent a Static Single Assignment (SSA) form
            of the control flow graph.
            </summary>
            <typeparam name="Instruction"></typeparam>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSABasicBlock`1.Joins">
            <summary>
            A potentially null (empty) list of locals 
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.Join">
            <summary>
            Records information about a local (or parameter) whose value can come from more than one SSA variable defined in ancestor blocks.
            Corresponds to a "Phi node" in SSA literature.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.Block1">
            <summary>
            The block from which control flowed to create Join1.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.Block2">
            <summary>
            The block from which control flowed to create Join2.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.OtherBlocks">
            <summary>
            A potentially null (empty) list of blocks from which control flowed to create OtherJoins. The order is the same, so OtherBlocks[i] will be the block that provided OtherJoins[i].
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.OriginalLocal">
            <summary>
            The local (or parameter) that appears in the original IL.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.NewLocal">
            <summary>
            The "SSA" local (or parameter) that is "written" by this join point (a.k.a. "Phi node")
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.Join1">
            <summary>
            A local written by an ancestor block that flows into this join point without an intervening write to OriginalLocal.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.Join2">
            <summary>
            A local written by another ancestor block that flows into this join point without an intervening write to OriginalLocal.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.OtherJoins">
            <summary>
            A potentially null (empty) set of locals written by other ancestor blocks that flows into this join point without an intervening write to OriginalLocal.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Join.Type">
            <summary>
            The type of the local (or parameter).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.Join.Next">
            <summary>
            The next local.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Join.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.Analysis.Join.ReadLocalEnumerator">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.Join.ReadLocalEnumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.Join.ReadLocalEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Cci.Analysis.SSALocalDefinition">
            <summary>
            A local definition that is just a new name (and object identity) for an existing local. The existing local
            can be recovered via the OriginalLocal property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSALocalDefinition.#ctor(Microsoft.Cci.ILocalDefinition,Microsoft.Cci.IName)">
            <summary>
            A local definition that is just a new name (and object identity) for an existing local. The existing local
            can be recovered via the OriginalLocal property.
            </summary>
            <param name="originalLocal">The local for which the new local provides a new name and new object identity.</param>
            <param name="name">The name of the new local.</param>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSALocalDefinition.name">
            <summary>
            The name of this local.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSALocalDefinition.originalLocal">
            <summary>
            The local for which this local provides a new name and new object identity.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.OriginalLocal">
            <summary>
            The local for which this local provides a new name and new object identity. 
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSALocalDefinition.ToString">
            <summary>
            Return the name of the local.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.CompileTimeValue">
            <summary>
            The compile time value of the definition, if it is a local constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.CustomModifiers">
            <summary>
            Custom modifiers associated with local variable definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.IsConstant">
            <summary>
            True if this local definition is readonly and initialized with a compile time constant value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.IsModified">
            <summary>
            The local variable has custom modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.IsPinned">
            <summary>
            True if the value referenced by the local must not be moved by the actions of the garbage collector.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.IsReference">
            <summary>
            True if the local contains a managed pointer (for example a reference to a local variable or a reference to a field of an object).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.MethodDefinition">
            <summary>
            The definition of the method in which this local is defined.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.Type">
            <summary>
            The type of the local.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.Name">
            <summary>
            The name of the entity.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSALocalDefinition.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.SSAParameterDefinition">
            <summary>
            A parameter definition that is just a new name (and object identity) for an existing parameter. The existing parameter
            can be recovered via the OriginalParameter property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSAParameterDefinition.#ctor(Microsoft.Cci.IParameterDefinition,Microsoft.Cci.IName,Microsoft.Cci.ITypeDefinition)">
            <summary>
            A parameter definition that is just a new name (and object identity) for an existing parameter. The existing parameter
            can be recovered via the OriginalParameter property.
            </summary>
            <param name="originalParameter">The parameter for which the new parameter provides a new name and new object identity.</param>
            <param name="name"></param>
            <param name="containingType"></param>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSAParameterDefinition.name">
            <summary>
            The name of this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSAParameterDefinition.originalParameter">
            <summary>
            The parameter for which this object provides a new name and new object identity.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.OriginalParameter">
            <summary>
            The parameter for which this object provides a new name and new object identity.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSAParameterDefinition.ToString">
            <summary>
            Returns the name of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.DefaultValue">
            <summary>
            A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.HasDefaultValue">
            <summary>
            True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsIn">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsMarshalledExplicitly">
            <summary>
            This parameter has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsOptional">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsOut">
            <summary>
            True if the final value assigned to the parameter will be marshalled with the return values passed back from a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsParameterArray">
            <summary>
            True if the parameter has the ParamArrayAttribute custom attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.MarshallingInformation">
            <summary>
            Specifies how this parameter is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.ParamArrayElementType">
            <summary>
            The element type of the parameter array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSAParameterDefinition.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.Visit(IParameterDefinition).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSAParameterDefinition.DispatchAsReference(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls visitor.VisitReference(IParameterDefinition).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Locations">
            <summary>
            A potentially empty collection of locations that correspond to this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Name">
            <summary>
            The name of the entity.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.ContainingSignature">
            <summary>
            The method or property that defines this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.IsModified">
            <summary>
            This parameter has one or more custom modifiers associated with it.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Type">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAParameterDefinition.Constant">
            <summary>
            The constant value associated with this metadata object. For example, the default value of a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.SSAOperation">
            <summary>
            A copy of an existing operation, whose Value property has been updated to reference a SSALocalDefinition or SSAParameterDefinition.
            The original operation can be recovered via the OriginalOperation property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.SSAOperation.#ctor(Microsoft.Cci.IOperation,System.Object)">
            <summary>
            A copy of an existing operation, whose Value property has been updated to reference a SSALocalDefinition or SSAParameterDefinition.
            The original operation can be recovered via the OriginalOperation property.
            </summary>
            <param name="originalOperation">The operation to copy into the new operation.</param>
            <param name="value">The object to use as the Value property of the new operation.</param>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSAOperation.originalOperation">
            <summary>
            The operation that was replaced by this object. It is the same as this object except for this.Value.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.Analysis.SSAOperation.value">
            <summary>
            The object to use as the Value property of this object. Usually an SSALocalDefinition or an SSAParameterDefinition
            but could be a Dummy.ParameterDefinition of the operation references the this value of an instance method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAOperation.OriginalOperation">
            <summary>
            The operation that was replaced by this object. It is the same as this object except for this.Value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAOperation.OperationCode">
            <summary>
            The actual value of the operation code
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAOperation.Offset">
            <summary>
            The offset from the start of the operation stream of a method
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAOperation.Location">
            <summary>
            The location that corresponds to this instruction.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.Analysis.SSAOperation.Value">
            <summary>
            Immediate data such as a string, the address of a branch target, or a metadata reference, such as a Field
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Analysis.ValueMappings`1">
            <summary>
            Provides several maps from expressions to concrete and abstract values.
            </summary>
            <typeparam name="Instruction">An instruction that results in value.</typeparam>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.#ctor(Microsoft.Cci.IPlatformType,Microsoft.Cci.Analysis.ISatSolver)">
            <summary>
            Provides several maps from expressions to concrete and abstract values.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetCompileTimeConstantValueFor(`0,Microsoft.Cci.Analysis.AiBasicBlock{`0})">
            <summary>
            Returns a compile time constant value that is known to be the value of the given expression in all possible executions of the analyzed method.
            If the value is Dummy.Constant, the expression is known to fail at runtime in all possible executions of the analyzed method.
            </summary>
            <param name="expression">The expression for which a compile time constant value is desired.</param>
            <param name="block">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible. May be null.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetCompileTimeConstantValueFor(Microsoft.Cci.INamedEntity)">
            <summary>
            Returns a compile time constant that is known to be the value that is assigned to the given variable in all possible executions of the analyzed method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetCanonicalExpressionFor(`0)">
            <summary>
            Returns an expression that results in the same value as the given expression in all possible executions of the analyzed method.
            May be null if no such expression can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetDefiningExpressionFor(Microsoft.Cci.INamedEntity)">
            <summary>
            Returns the expression which computes the value of the sole assignment to the given variable.
            This can be a NOP instruction, which is a "phi" node in the SSA. Can be null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetDefiningBlockFor(`0)">
            <summary>
            Returns the block that defined the given "phi" node expression. This is useful because the entry contraints of this block might provide
            additional information about the expression. If the block has not been defined earlier via SetDefiningBlockFor, the result will be null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetDefiningJoinFor(Microsoft.Cci.INamedEntity)">
            <summary>
            Return the Join information of the "phi" node that is the right hand side of the sole assignment to the given variable. Returns null if the variable is not
            defined by a "phi" node.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.GetIntervalFor(`0,Microsoft.Cci.Analysis.AiBasicBlock{`0})">
            <summary>
            Computes an inclusive numerical interval that contains the runtime value of the given expression. If no such interval can be found, the result is null.
            </summary>
            <param name="expression">The expression for which a containing interval is desired.</param>
            <param name="block">A block providing the context for the interval. The entry contraints of the block are used to narrow the interval if possible.</param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.IsRecursive(`0)">
            <summary>
            Returns true if the given expression is the value of a variable that is updated (inside of a loop) with a value that depends on the value of the variable in a an earlier iteration of the loop.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.CheckIfExpressionIsTrue(`0,Microsoft.Cci.Analysis.AiBasicBlock{`0})">
            <summary>
            Uses the SAT solver, if supplied, to check if the given Boolean expression is true in the context of the given block.
            Since this problem is not decidable, the solver may not be able to return an answer, in which case the return result is null
            rather than false or true. Likewise, if no solver is available, the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetCanonicalExpressionFor(`0,`0)">
            <summary>
            Associates the given expression with a canonical version that will always evaluate to the same value as the given expression. 
            </summary>
            <param name="expression"></param>
            <param name="canonicalExpression"></param>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetCompileTimeConstantValueFor(Microsoft.Cci.INamedEntity,Microsoft.Cci.IMetadataConstant)">
            <summary>
            Associates the given SSA variable with the compile time constant that is always the value of the right side of the single assignment to this variable.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetCompileTimeConstantValueFor(`0,Microsoft.Cci.IMetadataConstant)">
            <summary>
            Associates the given expression with a compile time constant value that is always its result when evaluated at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetDefininingBlockFor(`0,Microsoft.Cci.Analysis.AiBasicBlock{`0})">
            <summary>
            Keeps track of the block in which a "phi" node expression is defined. This is useful because the entry contraints of this block might provide
            additional information about the expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetDefininingExpressionFor(Microsoft.Cci.INamedEntity,`0)">
            <summary>
            Associates the given SSA variable with the expression (expected to be canonicalized) that is the right hand side of the single assignment to this variable.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetDefininingJoinFor(Microsoft.Cci.INamedEntity,Microsoft.Cci.Analysis.Join)">
            <summary>
            Associates the given SSA variable with the Join information of the "phi" node that that is the right hand side of the single assignment to this variable.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.Analysis.ValueMappings`1.SetIsRecursive(`0)">
            <summary>
            Records that the given expression is the value of a variable that is updated (inside of a loop) with a value that depends on the value of the variable in a an earlier iteration of the loop.
            </summary>
        </member>
    </members>
</doc>
